<!--
Generated by 'make udf_doc_gen'.  DO NOT EDIT!
---
title: udfs/udfs.h

---
# udfs/udfs.h

## Functions

| Name          | Description    |
| -------------- | -------------- |
| **[abs](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-abs)**()| <br>Return the absolute value of expr. |
| **[acos](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-acos)**()| <br>Return the arc cosine of expr. |
| **[add](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-add)**()| <br>Compute sum of two arguments. |
| **[add_months](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-add-months)**()| <br>adds an integer months to a given date, returning the resulting date. |
| **[array_contains](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-array-contains)**()| <br>array_contains(array, value) - Returns true if the array contains the value. |
| **[asin](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-asin)**()| <br>Return the arc sine of expr. |
| **[at](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-at)**()| |
| **[atan](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-atan)**()| <br>Return the arc tangent of expr If called with one parameter, this function returns the arc tangent of expr. If called with two parameters X and Y, this function returns the arc tangent of Y / X. |
| **[atan2](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-atan2)**()| <br>Return the arc tangent of Y / X.. |
| **[avg](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-avg)**()| <br>Compute average of values. |
| **[avg_cate](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-avg-cate)**()| <br>Compute average of values grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. |
| **[avg_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-avg-cate-where)**()| <br>Compute average of values matching specified condition grouped by category key and output string. Each group is represented as 'K:V', separated by comma, and sorted by key in ascend order. |
| **[avg_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-avg-where)**()| <br>Compute average of values match specified condition. |
| **[bool](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-bool)**()| <br>Cast string expression to bool. |
| **[ceil](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-ceil)**()| <br>Return the smallest integer value not less than the expr. |
| **[ceiling](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-ceiling)**()| |
| **[char](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-char)**()| <br>Returns the ASCII character having the binary equivalent to expr. If n >= 256 the result is equivalent to char(n % 256). |
| **[char_length](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-char-length)**()| <br>Returns the length of the string. It is measured in characters and multibyte character string is not supported. |
| **[character_length](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-character-length)**()| |
| **[concat](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-concat)**()| <br>This function returns a string resulting from the joining of two or more string values in an end-to-end manner. (To add a separating value during joining, see concat_ws.) |
| **[concat_ws](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-concat-ws)**()| <br>Returns a string resulting from the joining of two or more string value in an end-to-end manner. It separates those concatenated string values with the delimiter specified in the first function argument. |
| **[cos](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-cos)**()| <br>Return the cosine of expr. |
| **[cot](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-cot)**()| <br>Return the cotangent of expr. |
| **[count](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-count)**()| <br>Compute number of values. |
| **[count_cate](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-count-cate)**()| <br>Compute count of values grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. |
| **[count_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-count-cate-where)**()| <br>Compute count of values matching specified condition grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. |
| **[count_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-count-where)**()| <br>Compute number of values match specified condition. |
| **[date](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-date)**()| <br>Cast timestamp or string expression to date (date >= 1900-01-01) |
| **[date_format](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-date-format)**()| <br>Formats the date value according to the format string. |
| **[datediff](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-datediff)**()| <br>days difference from date1 to date2 |
| **[day](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-day)**()| |
| **[dayofmonth](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-dayofmonth)**()| <br>Return the day of the month for a timestamp or date. |
| **[dayofweek](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-dayofweek)**()| <br>Return the day of week for a timestamp or date. |
| **[dayofyear](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-dayofyear)**()| <br>Return the day of year for a timestamp or date. Returns 0 given an invalid date. |
| **[degrees](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-degrees)**()| <br>Convert radians to degrees. |
| **[distinct_count](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-distinct-count)**()| <br>Compute number of distinct values. |
| **[double](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-double)**()| <br>Cast string expression to double. |
| **[drawdown](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-drawdown)**()| <br>Compute drawdown of values. |
| **[earth_distance](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-earth-distance)**()| <br>Returns the great circle distance between two points on the surface of the Earth. Km as return unit. add a minus (-) sign if heading west (W) or south (S). |
| **[entropy](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-entropy)**()| <br>Calculate Shannon entropy of a column of values. Null values are skipped. |
| **[ew_avg](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-ew-avg)**()| <br>Compute exponentially-weighted average of values. It's equivalent to pandas ewm(alpha={alpha}, adjust=True, ignore_na=True, com=None, span=None, halflife=None, min_periods=0) |
| **[exp](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-exp)**()| <br>Return the value of e (the base of natural logarithms) raised to the power of expr. |
| **[farm_fingerprint](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-farm-fingerprint)**()| |
| **[first_value](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-first-value)**()| <br>Returns the value of expr from the latest row (last row) of the window frame. |
| **[float](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-float)**()| <br>Cast string expression to float. |
| **[floor](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-floor)**()| <br>Return the largest integer value not less than the expr. |
| **[hash64](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-hash64)**()| <br>Returns a hash value of the arguments. It is not a cryptographic hash function and should not be used as such. |
| **[hex](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-hex)**()| <br>Convert integer to hexadecimal. |
| **[hour](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-hour)**()| <br>Return the hour for a timestamp. |
| **[identity](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-identity)**()| <br>Return value. |
| **[if_null](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-if-null)**()| <br>If input is not null, return input value; else return default value. |
| **[ifnull](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-ifnull)**()| |
| **[ilike_match](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-ilike-match)**()| <br>pattern match same as ILIKE predicate |
| **[inc](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-inc)**()| <br>Return expression + 1. |
| **[int16](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-int16)**()| <br>Cast string expression to int16. |
| **[int32](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-int32)**()| <br>Cast string expression to int32. |
| **[int64](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-int64)**()| <br>Cast string expression to int64. |
| **[is_null](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-is-null)**()| <br>Check if input value is null, return bool. |
| **[isnull](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-isnull)**()| |
| **[join](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-join)**()| <br>For each string value from specified column of window, join by delimeter. Null values are skipped. |
| **[lag](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-lag)**()| <br>Returns value evaluated at the row that is offset rows before the current row within the partition. Offset is evaluated with respect to the current row. |
| **[last_day](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-last-day)**()| <br>Return the last day of the month to which the date belongs to. |
| **[lcase](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-lcase)**()| <br>Convert all the characters to lowercase. Note that characters with values > 127 are simply returned. |
| **[like_match](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-like-match)**()| <br>pattern match same as LIKE predicate |
| **[ln](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-ln)**()| <br>Return the natural logarithm of expr. |
| **[log](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-log)**()| <br>log(base, expr) If called with one parameter, this function returns the natural logarithm of expr. If called with two parameters, this function returns the logarithm of expr to the base. |
| **[log10](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-log10)**()| <br>Return the base-10 logarithm of expr. |
| **[log2](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-log2)**()| <br>Return the base-2 logarithm of expr. |
| **[lower](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-lower)**()| |
| **[make_tuple](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-make-tuple)**()| |
| **[max](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-max)**()| <br>Compute maximum of values. |
| **[max_cate](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-max-cate)**()| <br>Compute maximum of values grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. |
| **[max_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-max-cate-where)**()| <br>Compute maximum of values matching specified condition grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. |
| **[max_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-max-where)**()| <br>Compute maximum of values match specified condition. |
| **[maximum](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-maximum)**()| <br>Compute maximum of two arguments. |
| **[median](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-median)**()| <br>Compute the median of values. |
| **[min](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-min)**()| <br>Compute minimum of values. |
| **[min_cate](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-min-cate)**()| <br>Compute minimum of values grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. |
| **[min_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-min-cate-where)**()| <br>Compute minimum of values matching specified condition grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. |
| **[min_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-min-where)**()| <br>Compute minimum of values match specified condition. |
| **[minimum](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-minimum)**()| <br>Compute minimum of two arguments. |
| **[minute](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-minute)**()| <br>Return the minute for a timestamp. |
| **[month](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-month)**()| <br>Return the month part of a timestamp or date. |
| **[nth_value_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-nth-value-where)**()| <br>Returns the value of expr from the idx th row matches the condition. |
| **[nvl](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-nvl)**()| |
| **[nvl2](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-nvl2)**()| <br>nvl2(expr1, expr2, expr3) - Returns expr2 if expr1 is not null, or expr3 otherwise. |
| **[pmod](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-pmod)**()| <br>Compute pmod of two arguments. If any param is NULL, output NULL. If divisor is 0, output NULL. |
| **[pow](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-pow)**()| <br>Return the value of expr1 to the power of expr2. |
| **[power](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-power)**()| |
| **[radians](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-radians)**()| <br>Returns the argument X, converted from degrees to radians. (Note that Ï€ radians equals 180 degrees.) |
| **[regexp_like](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-regexp-like)**()| <br>pattern match same as RLIKE predicate (based on RE2) |
| **[replace](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-replace)**()| <br>replace(str, search[, replace]) - Replaces all occurrences of `search` with `replace`|
| **[reverse](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-reverse)**()| <br>Returns the reversed given string. |
| **[round](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-round)**()| <br>Returns expr rounded to d decimal places using HALF_UP rounding mode. |
| **[second](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-second)**()| <br>Return the second for a timestamp. |
| **[sin](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-sin)**()| <br>Return the sine of expr. |
| **[size](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-size)**()| <br>Get the size of a List (e.g., result of split) |
| **[split](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-split)**()| <br>Split string to list by delimeter. Null values are skipped. |
| **[split_array](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-split-array)**()| <br>Split string to array of string by delimeter. |
| **[split_by_key](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-split-by-key)**()| <br>Split string by delimeter and split each segment as kv pair, then add each key to output list. Null or illegal segments are skipped. |
| **[split_by_value](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-split-by-value)**()| <br>Split string by delimeter and split each segment as kv pair, then add each value to output list. Null or illegal segments are skipped. |
| **[sqrt](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-sqrt)**()| <br>Return square root of expr. |
| **[std](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-std)**()| |
| **[stddev](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-stddev)**()| <br>Compute sample standard deviation of values, i.e., `sqrt( sum((x_i - avg)^2) / (n-1) )`|
| **[stddev_pop](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-stddev-pop)**()| <br>Compute population standard deviation of values, i.e., `sqrt( sum((x_i - avg)^2) / n )`|
| **[stddev_samp](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-stddev-samp)**()| |
| **[strcmp](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-strcmp)**()| <br>Returns 0 if the strings are the same, -1 if the first argument is smaller than the second according to the current sort order, and 1 otherwise. |
| **[string](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-string)**()| <br>Return string converted from timestamp expression. |
| **[substr](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-substr)**()| |
| **[substring](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-substring)**()| <br>Return a substring `len` characters long from string str, starting at position `pos`. Alias function: `substr`|
| **[sum](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-sum)**()| <br>Compute sum of values. |
| **[sum_cate](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-sum-cate)**()| <br>Compute sum of values grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. |
| **[sum_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-sum-cate-where)**()| <br>Compute sum of values matching specified condition grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. |
| **[sum_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-sum-where)**()| <br>Compute sum of values match specified condition. |
| **[tan](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-tan)**()| <br>Return the tangent of expr. |
| **[timestamp](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-timestamp)**()| <br>Cast int64, date or string expression to timestamp. |
| **[top](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-top)**()| <br>Compute top k of values and output string separated by comma. The outputs are sorted in desc order. |
| **[top1_ratio](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-top1-ratio)**()| <br>Compute the top1 key's ratio. |
| **[top_n_key_avg_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-top-n-key-avg-cate-where)**()| <br>Compute average of values matching specified condition grouped by category key. Output string for top N category keys in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. |
| **[top_n_key_count_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-top-n-key-count-cate-where)**()| <br>Compute count of values matching specified condition grouped by category key. Output string for top N category keys in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. |
| **[top_n_key_max_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-top-n-key-max-cate-where)**()| <br>Compute maximum of values matching specified condition grouped by category key. Output string for top N category keys in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. |
| **[top_n_key_min_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-top-n-key-min-cate-where)**()| <br>Compute minimum of values matching specified condition grouped by category key. Output string for top N category keys in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. |
| **[top_n_key_sum_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-top-n-key-sum-cate-where)**()| <br>Compute sum of values matching specified condition grouped by category key. Output string for top N category keys in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. |
| **[top_n_value_avg_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-top-n-value-avg-cate-where)**()| <br>Compute average of values matching specified condition grouped by category key. Output string for top N aggregate values in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. |
| **[top_n_value_count_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-top-n-value-count-cate-where)**()| <br>Compute count of values matching specified condition grouped by category key. Output string for top N aggregate values in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. |
| **[top_n_value_max_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-top-n-value-max-cate-where)**()| <br>Compute maximum of values matching specified condition grouped by category key. Output string for top N aggregate values in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. |
| **[top_n_value_min_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-top-n-value-min-cate-where)**()| <br>Compute minimum of values matching specified condition grouped by category key. Output string for top N aggregate values in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. |
| **[top_n_value_sum_cate_where](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-top-n-value-sum-cate-where)**()| <br>Compute sum of values matching specified condition grouped by category key. Output string for top N aggregate values in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. |
| **[topn_frequency](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-topn-frequency)**()| <br>Return the topN keys sorted by their frequency. |
| **[truncate](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-truncate)**()| <br>Return the nearest integer that is not greater in magnitude than the expr. |
| **[ucase](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-ucase)**()| <br>Convert all the characters to uppercase. Note that characters values > 127 are simply returned. |
| **[unhex](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-unhex)**()| <br>Convert hexadecimal to binary string. |
| **[unix_timestamp](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-unix-timestamp)**()| <br>Cast date or string expression to unix_timestamp. If empty string or NULL is provided, return current timestamp. |
| **[upper](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-upper)**()| |
| **[var_pop](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-var-pop)**()| <br>Compute population variance of values, i.e., `sum((x_i - avg)^2) / n`|
| **[var_samp](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-var-samp)**()| <br>Compute population variance of values, i.e., `sum((x_i - avg)^2) / (n-1)`|
| **[variance](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-variance)**()| |
| **[week](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-week)**()| |
| **[weekofyear](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-weekofyear)**()| <br>Return the week of year for a timestamp or date. |
| **[window_split](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-window-split)**()| <br>For each string value from specified column of window, split by delimeter and add segment to output list. Null values are skipped. |
| **[window_split_by_key](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-window-split-by-key)**()| <br>For each string value from specified column of window, split by delimeter and then split each segment as kv pair, then add each key to output list. Null and illegal segments are skipped. |
| **[window_split_by_value](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-window-split-by-value)**()| <br>For each string value from specified column of window, split by delimeter and then split each segment as kv pair, then add each value to output list. Null and illegal segments are skipped. |
| **[year](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-year)**()| <br>Return the year part of a timestamp or date. |


## Functions Documentation
-->
# Built-in Functions

## Must read

Types in documents here may a little different from real types in OpenMLDB SQL, for the purpose of simplify. Those type are synonymics.

| Type literal | Same as any of those types in OpenMLDB SQL |
| ---------    | --------------------------------------     |
| number       | `int16, int32, int64, float, double`  |
| any          | `bool, int16, int32, int64, float, double, string, timestamp, date` |
| list<number> | `list<int16>, list<int32>, list<int64>, list<float>, list<double>` |

## Functions

### function abs

```cpp
abs()
```

**Description**:

Return the absolute value of expr. 

**Parameters**: 

  * **expr** 


**Since**:
0.1.0


Example:

```sql

SELECT ABS(-32);
-- output 32
```


**Supported Types**:

* [`bool`]
* [`number`] 

### function acos

```cpp
acos()
```

**Description**:

Return the arc cosine of expr. 

**Parameters**: 

  * **expr** 


**Since**:
0.1.0


Example:

```sql

SELECT ACOS(1);
-- output 0
```


**Supported Types**:

* [`number`] 

### function add

```cpp
add()
```

**Description**:

Compute sum of two arguments. 

**Since**:
0.1.0


Example:

```sql

select add(1, 2);
-- output 3
```


**Supported Types**:

* [`bool`, `bool`]
* [`bool`, `number`]
* [`bool`, `timestamp`]
* [`int16`, `timestamp`]
* [`int32`, `timestamp`]
* [`int64`, `timestamp`]
* [`number`, `bool`]
* [`number`, `number`]
* [`timestamp`, `bool`]
* [`timestamp`, `int16`]
* [`timestamp`, `int32`]
* [`timestamp`, `int64`]
* [`timestamp`, `timestamp`] 

### function add_months

```cpp
add_months()
```

**Description**:

adds an integer months to a given date, returning the resulting date. 

**Parameters**: 

  * **start_date** Date value to add 
  * **num_months** Integer value as number of months to add, can be positive or negative


**Since**:
0.8.0


The resulting day component will remain the same as that specified in date, unless the resulting month has fewer days than the day component of the given date, in which case the day will be the last day of the resulting month. Returns NULL if given an invalid date, or a NULL argument.

```sql

SELECT add_months('2016-08-31', 1);
-- 2016-09-30
SELECT add_months('2016-08-31', -1);
-- 2016-07-31
SELECT add_months('2012-01-31', 1);
-- 2012-02-29
```


**Supported Types**:

* [`date`, `int16`]
* [`date`, `int32`]
* [`date`, `int64`] 

### function array_contains

```cpp
array_contains()
```

**Description**:

array_contains(array, value) - Returns true if the array contains the value. 

**Since**:
0.7.0


Example:

```sql

select array_contains([2,2], 2) as c0;
-- output true
```


**Supported Types**:

* [array_bool, `bool`]
* [array_date, `date`]
* [array_double, `double`]
* [array_float, `float`]
* [array_int16, `int16`]
* [array_int32, `int32`]
* [array_int64, `int64`]
* [array_string, `string`]
* [array_timestamp, `timestamp`] 

### function asin

```cpp
asin()
```

**Description**:

Return the arc sine of expr. 

**Parameters**: 

  * **expr** 


**Since**:
0.1.0


Example:

```sql

SELECT ASIN(0.0);
-- output 0.000000
```


**Supported Types**:

* [`number`] 

### function at

```cpp
at()
```

**Description**:


alias to lag 

### function atan

```cpp
atan()
```

**Description**:

Return the arc tangent of expr If called with one parameter, this function returns the arc tangent of expr. If called with two parameters X and Y, this function returns the arc tangent of Y / X. 

**Parameters**: 

  * **X** 
  * **Y** 


**Since**:
0.1.0


Example:

```sql

SELECT ATAN(-0.0);
-- output -0.000000

SELECT ATAN(0, -0);
-- output 3.141593
```


**Supported Types**:

* [`bool`, `bool`]
* [`bool`, `number`]
* [`number`]
* [`number`, `bool`]
* [`number`, `number`] 

### function atan2

```cpp
atan2()
```

**Description**:

Return the arc tangent of Y / X.. 

**Parameters**: 

  * **X** 
  * **Y** 


**Since**:
0.1.0


Example:

```sql

SELECT ATAN2(0, -0);
-- output 3.141593
```


**Supported Types**:

* [`bool`, `bool`]
* [`bool`, `number`]
* [`number`, `bool`]
* [`number`, `number`] 

### function avg

```cpp
avg()
```

**Description**:

Compute average of values. 

**Parameters**: 

  * **value** Specify value column to aggregate on.


**Since**:
0.1.0



Example:


| value     |
|  -------- |
| 0     |
| 1     |
| 2     |
| 3     |
| 4    |


```sql

SELECT avg(value) OVER w;
-- output 2
```


**Supported Types**:

* [`list<number>`] 

### function avg_cate

```cpp
avg_cate()
```

**Description**:

Compute average of values grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **catagory** Specify catagory column to group by.



Example:


| value    | catagory     |
|  -------- | -------- |
| 0    | x     |
| 1    | y     |
| 2    | x     |
| 3    | y     |
| 4    | x    |


```sql

SELECT avg_cate(value, catagory) OVER w;
-- output "x:2,y:2"
```

**Supported Types**:

* [`list<number>`, `list<date>`]
* [`list<number>`, `list<int16>`]
* [`list<number>`, `list<int32>`]
* [`list<number>`, `list<int64>`]
* [`list<number>`, `list<string>`]
* [`list<number>`, `list<timestamp>`] 

### function avg_cate_where

```cpp
avg_cate_where()
```

**Description**:

Compute average of values matching specified condition grouped by category key and output string. Each group is represented as 'K:V', separated by comma, and sorted by key in ascend order. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | false    | y     |
| 2    | false    | x     |
| 3    | true    | y     |
| 4    | true    | x    |


```sql

SELECT avg_cate_where(value, condition, category) OVER w;
-- output "x:2,y:3"
```

**Supported Types**:

* [`list<number>`, `list<bool>`, `list<date>`]
* [`list<number>`, `list<bool>`, `list<int16>`]
* [`list<number>`, `list<bool>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`] 

### function avg_where

```cpp
avg_where()
```

**Description**:

Compute average of values match specified condition. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column.


**Since**:
0.1.0



Example:


| value     |
|  -------- |
| 0     |
| 1     |
| 2     |
| 3     |
| 4    |


```sql

SELECT avg_where(value, value > 2) OVER w;
-- output 3.5
```


**Supported Types**:

* [`list<number>`, `list<bool>`] 

### function bool

```cpp
bool()
```

**Description**:

Cast string expression to bool. 

**Since**:
0.1.0


Example:

```sql

select bool("true");
-- output true
```


**Supported Types**:

* [`string`] 

### function ceil

```cpp
ceil()
```

**Description**:

Return the smallest integer value not less than the expr. 

**Parameters**: 

  * **expr** 


**Since**:
0.1.0


Example:

```sql

SELECT CEIL(1.23);
-- output 2
```


**Supported Types**:

* [`bool`]
* [`number`] 

### function ceiling

```cpp
ceiling()
```

**Description**:


alias to ceil 

### function char

```cpp
char()
```

**Description**:

Returns the ASCII character having the binary equivalent to expr. If n >= 256 the result is equivalent to char(n % 256). 

**Since**:
0.6.0


Example:

```sql

SELECT char(65);
--output "A"
```


**Supported Types**:

* [`int32`] 

### function char_length

```cpp
char_length()
```

**Description**:

Returns the length of the string. It is measured in characters and multibyte character string is not supported. 

**Since**:
0.6.0


Example:

```sql

SELECT CHAR_LENGTH('Spark SQL ');
--output 10
```


**Supported Types**:

* [`string`] 

### function character_length

```cpp
character_length()
```

**Description**:


alias to char_length 

### function concat

```cpp
concat()
```

**Description**:

This function returns a string resulting from the joining of two or more string values in an end-to-end manner. (To add a separating value during joining, see concat_ws.) 

**Since**:
0.1.0


Example:

```sql

select concat("1", 2, 3, 4, 5.6, 7.8, Timestamp(1590115420000L));
-- output "12345.67.82020-05-22 10:43:40"
```


**Supported Types**:

* [...] 

### function concat_ws

```cpp
concat_ws()
```

**Description**:

Returns a string resulting from the joining of two or more string value in an end-to-end manner. It separates those concatenated string values with the delimiter specified in the first function argument. 

**Since**:
0.1.0


Example:

```sql

select concat_ws("-", "1", 2, 3, 4, 5.6, 7.8, Timestamp(1590115420000L));
-- output "1-2-3-4-5.6-7.8-2020-05-22 10:43:40"
```


**Supported Types**:

* [`any`, ...] 

### function cos

```cpp
cos()
```

**Description**:

Return the cosine of expr. 

**Parameters**: 

  * **expr** It is a single argument in radians.


**Since**:
0.1.0


Example:

```sql

SELECT COS(0);
-- output 1.000000
```



* The value returned by [cos()](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-cos) is always in the range: -1 to 1.


**Supported Types**:

* [`number`] 

### function cot

```cpp
cot()
```

**Description**:

Return the cotangent of expr. 

**Parameters**: 

  * **expr** 


**Since**:
0.1.0


Example:

```sql

SELECT COT(1);
-- output 0.6420926159343306
```


**Supported Types**:

* [`number`] 

### function count

```cpp
count()
```

**Description**:

Compute number of values. 

**Parameters**: 

  * **value** Specify value column to aggregate on.


**Since**:
0.1.0



Example:


| value     |
|  -------- |
| 0     |
| 1     |
| 2     |
| 3     |
| 4    |


```sql

SELECT count(value) OVER w;
-- output 5
```


**Supported Types**:

* [`list<bool>`]
* [`list<date>`]
* [`list<number>`]
* [`list<row>`]
* [`list<string>`]
* [`list<timestamp>`] 

### function count_cate

```cpp
count_cate()
```

**Description**:

Compute count of values grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **catagory** Specify catagory column to group by.



Example:


| value    | catagory     |
|  -------- | -------- |
| 0    | x     |
| 1    | y     |
| 2    | x     |
| 3    | y     |
| 4    | x    |


```sql

SELECT count_cate(value, catagory) OVER w;
-- output "x:3,y:2"
```

**Supported Types**:

* [`list<bool>`, `list<date>`]
* [`list<bool>`, `list<int16>`]
* [`list<bool>`, `list<int32>`]
* [`list<bool>`, `list<int64>`]
* [`list<bool>`, `list<string>`]
* [`list<bool>`, `list<timestamp>`]
* [`list<date>`, `list<date>`]
* [`list<date>`, `list<int16>`]
* [`list<date>`, `list<int32>`]
* [`list<date>`, `list<int64>`]
* [`list<date>`, `list<string>`]
* [`list<date>`, `list<timestamp>`]
* [`list<number>`, `list<date>`]
* [`list<number>`, `list<int16>`]
* [`list<number>`, `list<int32>`]
* [`list<number>`, `list<int64>`]
* [`list<number>`, `list<string>`]
* [`list<number>`, `list<timestamp>`]
* [`list<string>`, `list<date>`]
* [`list<string>`, `list<int16>`]
* [`list<string>`, `list<int32>`]
* [`list<string>`, `list<int64>`]
* [`list<string>`, `list<string>`]
* [`list<string>`, `list<timestamp>`]
* [`list<timestamp>`, `list<date>`]
* [`list<timestamp>`, `list<int16>`]
* [`list<timestamp>`, `list<int32>`]
* [`list<timestamp>`, `list<int64>`]
* [`list<timestamp>`, `list<string>`]
* [`list<timestamp>`, `list<timestamp>`] 

### function count_cate_where

```cpp
count_cate_where()
```

**Description**:

Compute count of values matching specified condition grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | false    | y     |
| 2    | false    | x     |
| 3    | true    | y     |
| 4    | true    | x    |


```sql

SELECT count_cate_where(value, condition, category) OVER w;
-- output "x:2,y:1"
```

**Supported Types**:

* [`list<bool>`, `list<bool>`, `list<date>`]
* [`list<bool>`, `list<bool>`, `list<int16>`]
* [`list<bool>`, `list<bool>`, `list<int32>`]
* [`list<bool>`, `list<bool>`, `list<int64>`]
* [`list<bool>`, `list<bool>`, `list<string>`]
* [`list<bool>`, `list<bool>`, `list<timestamp>`]
* [`list<date>`, `list<bool>`, `list<date>`]
* [`list<date>`, `list<bool>`, `list<int16>`]
* [`list<date>`, `list<bool>`, `list<int32>`]
* [`list<date>`, `list<bool>`, `list<int64>`]
* [`list<date>`, `list<bool>`, `list<string>`]
* [`list<date>`, `list<bool>`, `list<timestamp>`]
* [`list<number>`, `list<bool>`, `list<date>`]
* [`list<number>`, `list<bool>`, `list<int16>`]
* [`list<number>`, `list<bool>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`]
* [`list<string>`, `list<bool>`, `list<date>`]
* [`list<string>`, `list<bool>`, `list<int16>`]
* [`list<string>`, `list<bool>`, `list<int32>`]
* [`list<string>`, `list<bool>`, `list<int64>`]
* [`list<string>`, `list<bool>`, `list<string>`]
* [`list<string>`, `list<bool>`, `list<timestamp>`]
* [`list<timestamp>`, `list<bool>`, `list<date>`]
* [`list<timestamp>`, `list<bool>`, `list<int16>`]
* [`list<timestamp>`, `list<bool>`, `list<int32>`]
* [`list<timestamp>`, `list<bool>`, `list<int64>`]
* [`list<timestamp>`, `list<bool>`, `list<string>`]
* [`list<timestamp>`, `list<bool>`, `list<timestamp>`] 

### function count_where

```cpp
count_where()
```

**Description**:

Compute number of values match specified condition. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column.


**Since**:
0.1.0



Example:


| value     |
|  -------- |
| 0     |
| 1     |
| 2     |
| 3     |
| 4    |


```sql

SELECT count_where(value, value > 2) OVER w;
-- output 2
```


**Supported Types**:

* [`list<bool>`, `list<bool>`]
* [`list<date>`, `list<bool>`]
* [`list<number>`, `list<bool>`]
* [`list<row>`, `list<bool>`]
* [`list<string>`, `list<bool>`]
* [`list<timestamp>`, `list<bool>`] 

### function date

```cpp
date()
```

**Description**:

Cast timestamp or string expression to date (date >= 1900-01-01) 

**Since**:
0.1.0


Supported string style:

* yyyy-mm-dd
* yyyymmdd
* yyyy-mm-dd hh:mm:ss

Example:

```sql

select date(timestamp(1590115420000));
-- output 2020-05-22
select date("2020-05-22");
-- output 2020-05-22
```


**Supported Types**:

* [`string`]
* [`timestamp`] 

### function date_format

```cpp
date_format()
```

**Description**:

Formats the date value according to the format string. 

Example:

```sql

select date_format(date(timestamp(1590115420000)),"%Y-%m-%d");
--output "2020-05-22"
```

**Supported Types**:

* [`date`, `string`]
* [`timestamp`, `string`] 

### function datediff

```cpp
datediff()
```

**Description**:

days difference from date1 to date2 

**Since**:
0.7.0


Supported date string style:

* yyyy-mm-dd
* yyyymmdd
* yyyy-mm-dd hh:mm:ss

Example:

```sql

select datediff("2021-05-10", "2021-05-01");
-- output 9
select datediff("2021-04-10", "2021-05-01");
-- output -21
select datediff(Date("2021-04-10"), Date("2021-05-01"));
-- output -21
```


**Supported Types**:

* [`date`, `date`]
* [`date`, `string`]
* [`string`, `date`]
* [`string`, `string`] 

### function day

```cpp
day()
```

**Description**:


alias to dayofmonth 

### function dayofmonth

```cpp
dayofmonth()
```

**Description**:

Return the day of the month for a timestamp or date. 

**Since**:
0.1.0


Note: This function equals the `[day()](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-day)` function.

Example:

```sql

select dayofmonth(timestamp(1590115420000));
-- output 22

select day(timestamp(1590115420000));
-- output 22
```


**Supported Types**:

* [`date`]
* [`int64`]
* [`timestamp`] 

### function dayofweek

```cpp
dayofweek()
```

**Description**:

Return the day of week for a timestamp or date. 

**Since**:
0.4.0


Note: This function equals the `[week()](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-week)` function.

Example:

```sql

select dayofweek(timestamp(1590115420000));
-- output 6
```


**Supported Types**:

* [`date`]
* [`int64`]
* [`timestamp`] 

### function dayofyear

```cpp
dayofyear()
```

**Description**:

Return the day of year for a timestamp or date. Returns 0 given an invalid date. 

**Since**:
0.1.0


Example:

```sql

select dayofyear(timestamp(1590115420000));
-- output 143

select dayofyear(1590115420000);
-- output 143

select dayofyear(date("2020-05-22"));
-- output 143

select dayofyear(date("2020-05-32"));
-- output 0
```


**Supported Types**:

* [`date`]
* [`int64`]
* [`timestamp`] 

### function degrees

```cpp
degrees()
```

**Description**:

Convert radians to degrees. 

**Parameters**: 

  * **expr** 


**Since**:
0.5.0


Example:

```sql

SELECT degrees(3.141592653589793);
-- output  180.0
```


**Supported Types**:

* [`double`] 

### function distinct_count

```cpp
distinct_count()
```

**Description**:

Compute number of distinct values. 

**Parameters**: 

  * **value** Specify value column to aggregate on.


**Since**:
0.1.0



Example:


| value     |
|  -------- |
| 0     |
| 0     |
| 2     |
| 2     |
| 4    |


```sql

SELECT distinct_count(value) OVER w;
-- output 3
```


**Supported Types**:

* [`list<bool>`]
* [`list<date>`]
* [`list<number>`]
* [`list<string>`]
* [`list<timestamp>`] 

### function double

```cpp
double()
```

**Description**:

Cast string expression to double. 

**Since**:
0.1.0


Example:

```sql

select double("1.23");
-- output 1.23
```


**Supported Types**:

* [`string`] 

### function drawdown

```cpp
drawdown()
```

**Description**:

Compute drawdown of values. 

**Parameters**: 

  * **value** Specify value column to aggregate on.


**Since**:
0.7.2


Drawdown is defined as the max decline percentage from a historical peak to a subsequent valley. It is commonly used as an indicator of risk in quant-trading to measure the max loss.

It requires that values are ordered so that it can only be used with WINDOW (PARTITION BY xx ORDER BY xx). GROUP BY and full table aggregation are not supported.


It requires that all values are non-negative. Negative values will be ignored.

Example:


| value     |
|  -------- |
| 1     |
| 8     |
| 5     |
| 2     |
| 10     |
| 4    |


```sql

SELECT drawdown(value) OVER w;
-- output 0.75 (decline from 8 to 2)
```


**Supported Types**:

* [`list<number>`] 

### function earth_distance

```cpp
earth_distance()
```

**Description**:

Returns the great circle distance between two points on the surface of the Earth. Km as return unit. add a minus (-) sign if heading west (W) or south (S). 

**Parameters**: 

  * **ll1** First latitude in degree 
  * **ll2** First longitude in degree 
  * **rl1** second latitude in degree 
  * **rl2** Second longitude in degree


**Since**:
0.8.0



Example:

```sql

select earth_distance(40, 73, 41, 74)
-- output 139.7
```


**Supported Types**:

* [`any`, `any`, `any`, `any`] 

### function entropy

```cpp
entropy()
```

**Description**:

Calculate Shannon entropy of a column of values. Null values are skipped. 

**Parameters**: 

  * **value** Specify value column to aggregate on.


**Since**:
0.8.0



Example:

| col1 | | 1 | | 1 | | 2 | | 3 |

```sql

select entropy(col1) from t1
-- output 1.5
```


**Supported Types**:

* [`list<bool>`]
* [`list<date>`]
* [`list<number>`]
* [`list<string>`]
* [`list<timestamp>`] 

### function ew_avg

```cpp
ew_avg()
```

**Description**:

Compute exponentially-weighted average of values. It's equivalent to pandas ewm(alpha={alpha}, adjust=True, ignore_na=True, com=None, span=None, halflife=None, min_periods=0) 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **alpha** Specify smoothing factor alpha (0 <= alpha <= 1). If NULL or 0, fall back to normal `avg`


**Since**:
0.7.2


It requires that values are ordered so that it can only be used with WINDOW (PARTITION BY xx ORDER BY xx). Undefined behaviour if it is used with GROUP BY and full table aggregation.


Example:


| value     |
|  -------- |
| 0     |
| 1     |
| 2     |
| 3     |
| 4    |


```sql

SELECT ew_avg(value, 0.5) OVER w;
-- output 3.161290
```


**Supported Types**:

* [`list<number>`, `list<double>`] 

### function exp

```cpp
exp()
```

**Description**:

Return the value of e (the base of natural logarithms) raised to the power of expr. 

**Parameters**: 

  * **expr** 


**Since**:
0.1.0


```sql

SELECT EXP(0);
-- output 1
```


**Supported Types**:

* [`number`] 

### function farm_fingerprint

```cpp
farm_fingerprint()
```

**Description**:


alias to hash64 

### function first_value

```cpp
first_value()
```

**Description**:

Returns the value of expr from the latest row (last row) of the window frame. 

**Since**:
0.1.0


Example:

```sql

select id, gp, ts, first_value(ts) over w as agg from t1
window w as (partition by gp order by ts rows between 3 preceding and current row);
```


| id    | gp    | ts    | agg     |
|  -------- | -------- | -------- | -------- |
| 1    | 100    | 98    | 98     |
| 2    | 100    | 99    | 99     |
| 3    | 100    | 100    | 100    |



**Supported Types**: 

### function float

```cpp
float()
```

**Description**:

Cast string expression to float. 

**Since**:
0.1.0


Example:

```sql

select float("1.23");
-- output 1.23
```


**Supported Types**:

* [`string`] 

### function floor

```cpp
floor()
```

**Description**:

Return the largest integer value not less than the expr. 

**Parameters**: 

  * **expr** 


**Since**:
0.1.0


Example:

```sql

SELECT FLOOR(1.23);
-- output 1
```


**Supported Types**:

* [`bool`]
* [`number`] 

### function hash64

```cpp
hash64()
```

**Description**:

Returns a hash value of the arguments. It is not a cryptographic hash function and should not be used as such. 

**Since**:
0.7.0


Example:

```sql

SELECT hash64(cast(90 as int));
--output -3754664774081171349
```


**Supported Types**:

* [`any`] 

### function hex

```cpp
hex()
```

**Description**:

Convert integer to hexadecimal. 

**Since**:
0.6.0


Example:

```sql

select hex("Spark SQL");
--output "537061726B2053514C"
```


**Supported Types**:

* [`number`]
* [`string`] 

### function hour

```cpp
hour()
```

**Description**:

Return the hour for a timestamp. 

**Since**:
0.1.0


Example:

```sql

select hour(timestamp(1590115420000));
-- output 10
```


**Supported Types**:

* [`int64`]
* [`timestamp`] 

### function identity

```cpp
identity()
```

**Description**:

Return value. 

**Since**:
0.1.0


Example:

```sql

select identity(1);
-- output 1
```


**Supported Types**:

* [`any`] 

### function if_null

```cpp
if_null()
```

**Description**:

If input is not null, return input value; else return default value. 

**Parameters**: 

  * **input** Input value 
  * **default** Default value if input is null


**Since**:
0.1.0


Example:

```sql

SELECT if_null("hello", "default"), if_null(cast(null as string), "default");
-- output ["hello", "default"]
```


**Supported Types**:

* [`any`, `any`] 

### function ifnull

```cpp
ifnull()
```

**Description**:


alias to if_null 

### function ilike_match

```cpp
ilike_match()
```

**Description**:

pattern match same as ILIKE predicate 

**Parameters**: 

  * **target** string to match
  * **pattern** the glob match pattern


**Since**:
0.4.0


Rules:

1. Special characters:
    * underscore(_): exact one character
    * precent(%): zero or more characters.
2. Escape character: backslash() is the default escape character
3. case insensitive
4. backslash: sql string literal use backslash() for escape sequences, write '\' as backslash itself
5. Return NULL if target or pattern is NULL

Example:

```sql

select ilike_match('Mike', 'Mi_k')
-- output: true

select ilike_match('Mike', 'mi_k')
-- output: true
```


**Supported Types**:

* [`string`, `string`]
* [`string`, `string`, `string`] 

### function inc

```cpp
inc()
```

**Description**:

Return expression + 1. 

**Since**:
0.1.0


Example:

```sql

select inc(1);
-- output 2
```


**Supported Types**:

* [`number`] 

### function int16

```cpp
int16()
```

**Description**:

Cast string expression to int16. 

**Since**:
0.1.0


Example:

```sql

select int16("123");
-- output 123
```


**Supported Types**:

* [`string`] 

### function int32

```cpp
int32()
```

**Description**:

Cast string expression to int32. 

**Since**:
0.1.0


Example:

```sql

select int32("12345");
-- output 12345
```


**Supported Types**:

* [`string`] 

### function int64

```cpp
int64()
```

**Description**:

Cast string expression to int64. 

**Since**:
0.1.0


Example:

```sql

select int64("1590115420000");
-- output 1590115420000
```


**Supported Types**:

* [`string`] 

### function is_null

```cpp
is_null()
```

**Description**:

Check if input value is null, return bool. 

**Parameters**: 

  * **input** Input value


**Since**:
0.1.0



**Supported Types**:

* [`any`] 

### function isnull

```cpp
isnull()
```

**Description**:


alias to is_null 

### function join

```cpp
join()
```

**Description**:

For each string value from specified column of window, join by delimeter. Null values are skipped. 

**Parameters**: 

  * **input** List of string to join 
  * **delimeter** Join delimeter


**Since**:
0.6.5



Example:

```sql

select `join`(split("k1:v1,k2:v2", ","), " ");
--  "k1:v1 k2:v2"
```


**Supported Types**:

* [`list<string>`, `string`] 

### function lag

```cpp
lag()
```

**Description**:

Returns value evaluated at the row that is offset rows before the current row within the partition. Offset is evaluated with respect to the current row. 

**Parameters**: 

  * **offset** The number of rows forwarded from the current row, must not negative


Note: This function equals the `[at()](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-at)` function.

The offset in window is `nth_value()`, not `[lag()](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-lag)/at()`. The old `[at()](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-at)`(version < 0.5.0) is start from the last row of window(may not be the current row), it's more like `nth_value()`


Example:


| c1    | c2     |
|  -------- | -------- |
| 0    | 1     |
| 1    | 1     |
| 2    | 2     |
| 3    | 2     |
| 4    | 2    |


```sql

SELECT lag(c1, 1) over w as co from t1 window w as(partition by c2 order by c1 rows between unbounded preceding and current row);
-- output
-- | co |
-- |----|
-- |NULL|
-- |0   |
-- |NULL|
-- |2   |
-- |3   |
SELECT at(c1, 1) over w as co from t1 window w as(partition by c2 order by c1 rows between unbounded preceding and current row);
-- output
-- | co |
-- |----|
-- |NULL|
-- |0   |
-- |NULL|
-- |2   |
-- |3   |
```

**Supported Types**:

* [`list<bool>`, `int64`]
* [`list<date>`, `int64`]
* [`list<number>`, `int64`]
* [`list<string>`, `int64`]
* [`list<timestamp>`, `int64`] 

### function last_day

```cpp
last_day()
```

**Description**:

Return the last day of the month to which the date belongs to. 

**Since**:
0.6.1


Example:

```sql

select last_day(timestamp("2020-05-22 10:43:40"));
-- output 2020-05-31
select last_day(timestamp("2020-02-12 10:43:40"));
-- output 2020-02-29
select last_day(timestamp("2021-02-12"));
-- output 2021-02-28
```


**Supported Types**:

* [`date`]
* [`int64`]
* [`timestamp`] 

### function lcase

```cpp
lcase()
```

**Description**:

Convert all the characters to lowercase. Note that characters with values > 127 are simply returned. 

**Since**:
0.5.0


Example:

```sql

SELECT LCASE('SQl') as str1;
--output "sql"
```


**Supported Types**:

* [`string`] 

### function like_match

```cpp
like_match()
```

**Description**:

pattern match same as LIKE predicate 

**Parameters**: 

  * **target** string to match
  * **pattern** the glob match pattern


**Since**:
0.4.0


Rules:

1. Special characters:
    * underscore(_): exact one character
    * precent(%): zero or more characters.
2. Escape character is backslash() by default
3. case sensitive
4. backslash: sql string literal use backslash() for escape sequences, write '\' as backslash itself
5. if one or more of target, pattern then the result is null

Example:

```sql

select like_match('Mike', 'Mi_k')
-- output: true
select like_match('Mike', 'mi_k')
-- output: false
```


**Supported Types**:

* [`string`, `string`]
* [`string`, `string`, `string`] 

### function ln

```cpp
ln()
```

**Description**:

Return the natural logarithm of expr. 

**Parameters**: 

  * **expr** 


**Since**:
0.1.0


Example:

```sql

SELECT LN(1);
-- output 0.000000
```


**Supported Types**:

* [`bool`]
* [`number`] 

### function log

```cpp
log()
```

**Description**:

log(base, expr) If called with one parameter, this function returns the natural logarithm of expr. If called with two parameters, this function returns the logarithm of expr to the base. 

**Parameters**: 

  * **base** 
  * **expr** 


**Since**:
0.1.0


Example:

```sql

SELECT LOG(1);
-- output 0.000000

SELECT LOG(10,100);
-- output 2
```


**Supported Types**:

* [`bool`]
* [`bool`, `any`]
* [`number`]
* [`number`, `any`] 

### function log10

```cpp
log10()
```

**Description**:

Return the base-10 logarithm of expr. 

**Parameters**: 

  * **expr** 


**Since**:
0.1.0


Example:

```sql

SELECT LOG10(100);
-- output 2
```


**Supported Types**:

* [`bool`]
* [`number`] 

### function log2

```cpp
log2()
```

**Description**:

Return the base-2 logarithm of expr. 

**Parameters**: 

  * **expr** 


**Since**:
0.1.0


Example:

```sql

SELECT LOG2(65536);
-- output 16
```


**Supported Types**:

* [`bool`]
* [`number`] 

### function lower

```cpp
lower()
```

**Description**:


alias to lcase 

### function make_tuple

```cpp
make_tuple()
```

**Description**:


**Supported Types**:

* [...] 

### function max

```cpp
max()
```

**Description**:

Compute maximum of values. 

**Parameters**: 

  * **value** Specify value column to aggregate on.


**Since**:
0.1.0



Example:


| value     |
|  -------- |
| 0     |
| 1     |
| 2     |
| 3     |
| 4    |


```sql

SELECT max(value) OVER w;
-- output 4
```


**Supported Types**:

* [`list<date>`]
* [`list<number>`]
* [`list<string>`]
* [`list<timestamp>`] 

### function max_cate

```cpp
max_cate()
```

**Description**:

Compute maximum of values grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **catagory** Specify catagory column to group by.



Example:


| value    | catagory     |
|  -------- | -------- |
| 0    | x     |
| 1    | y     |
| 2    | x     |
| 3    | y     |
| 4    | x    |


```sql

SELECT max_cate(value, catagory) OVER w;
-- output "x:4,y:3"
```

**Supported Types**:

* [`list<number>`, `list<date>`]
* [`list<number>`, `list<int16>`]
* [`list<number>`, `list<int32>`]
* [`list<number>`, `list<int64>`]
* [`list<number>`, `list<string>`]
* [`list<number>`, `list<timestamp>`] 

### function max_cate_where

```cpp
max_cate_where()
```

**Description**:

Compute maximum of values matching specified condition grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | false    | y     |
| 2    | false    | x     |
| 3    | true    | y     |
| 4    | true    | x    |


```sql

SELECT max_cate_where(value, condition, category) OVER w;
-- output "x:4,y:3"
```

**Supported Types**:

* [`list<number>`, `list<bool>`, `list<date>`]
* [`list<number>`, `list<bool>`, `list<int16>`]
* [`list<number>`, `list<bool>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`] 

### function max_where

```cpp
max_where()
```

**Description**:

Compute maximum of values match specified condition. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column.


**Since**:
0.1.0



Example:


| value     |
|  -------- |
| 0     |
| 1     |
| 2     |
| 3     |
| 4    |


```sql

SELECT max_where(value, value <= 2) OVER w;
-- output 2
```


**Supported Types**:

* [`list<number>`, `list<bool>`] 

### function maximum

```cpp
maximum()
```

**Description**:

Compute maximum of two arguments. 

**Since**:
0.1.0



**Supported Types**:

* [`any`, `string`]
* [`bool`, `bool`]
* [`bool`, `number`]
* [`date`, `date`]
* [`number`, `bool`]
* [`number`, `number`]
* [`string`, `bool`]
* [`string`, `date`]
* [`string`, `number`]
* [`string`, `timestamp`]
* [`timestamp`, `timestamp`] 

### function median

```cpp
median()
```

**Description**:

Compute the median of values. 

**Parameters**: 

  * **value** Specify value column to aggregate on.


**Since**:
0.6.0



Example:


| value     |
|  -------- |
| 1     |
| 2     |
| 3     |
| 4    |


```sql

SELECT median(value) OVER w;
-- output 2.5
```


**Supported Types**:

* [`list<number>`] 

### function min

```cpp
min()
```

**Description**:

Compute minimum of values. 

**Parameters**: 

  * **value** Specify value column to aggregate on.


**Since**:
0.1.0



Example:


| value     |
|  -------- |
| 0     |
| 1     |
| 2     |
| 3     |
| 4    |


```sql

SELECT min(value) OVER w;
-- output 0
```


**Supported Types**:

* [`list<date>`]
* [`list<number>`]
* [`list<string>`]
* [`list<timestamp>`] 

### function min_cate

```cpp
min_cate()
```

**Description**:

Compute minimum of values grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **catagory** Specify catagory column to group by.



Example:


| value    | catagory     |
|  -------- | -------- |
| 0    | x     |
| 1    | y     |
| 2    | x     |
| 3    | y     |
| 4    | x    |


```sql

SELECT min_cate(value, catagory) OVER w;
-- output "x:0,y:1"
```

**Supported Types**:

* [`list<number>`, `list<date>`]
* [`list<number>`, `list<int16>`]
* [`list<number>`, `list<int32>`]
* [`list<number>`, `list<int64>`]
* [`list<number>`, `list<string>`]
* [`list<number>`, `list<timestamp>`] 

### function min_cate_where

```cpp
min_cate_where()
```

**Description**:

Compute minimum of values matching specified condition grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | false    | y     |
| 2    | false    | x     |
| 1    | true    | y     |
| 4    | true    | x     |
| 3    | true    | y    |


```sql

SELECT min_cate_where(value, condition, category) OVER w;
-- output "x:0,y:1"
```

**Supported Types**:

* [`list<number>`, `list<bool>`, `list<date>`]
* [`list<number>`, `list<bool>`, `list<int16>`]
* [`list<number>`, `list<bool>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`] 

### function min_where

```cpp
min_where()
```

**Description**:

Compute minimum of values match specified condition. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column.


**Since**:
0.1.0



Example:


| value     |
|  -------- |
| 0     |
| 1     |
| 2     |
| 3     |
| 4    |


```sql

SELECT min_where(value, value > 2) OVER w;
-- output 3
```


**Supported Types**:

* [`list<number>`, `list<bool>`] 

### function minimum

```cpp
minimum()
```

**Description**:

Compute minimum of two arguments. 

**Since**:
0.1.0



**Supported Types**:

* [`any`, `string`]
* [`bool`, `bool`]
* [`bool`, `number`]
* [`date`, `date`]
* [`number`, `bool`]
* [`number`, `number`]
* [`string`, `bool`]
* [`string`, `date`]
* [`string`, `number`]
* [`string`, `timestamp`]
* [`timestamp`, `timestamp`] 

### function minute

```cpp
minute()
```

**Description**:

Return the minute for a timestamp. 

**Since**:
0.1.0


Example:

```sql

select minute(timestamp(1590115420000));
-- output 43
```


**Supported Types**:

* [`int64`]
* [`timestamp`] 

### function month

```cpp
month()
```

**Description**:

Return the month part of a timestamp or date. 

**Since**:
0.1.0


Example:

```sql

select month(timestamp(1590115420000));
-- output 5
```


**Supported Types**:

* [`date`]
* [`int64`]
* [`timestamp`] 

### function nth_value_where

```cpp
nth_value_where()
```

**Description**:

Returns the value of expr from the idx th row matches the condition. 

**Parameters**: 

  * **value** Expr of the matched row 
  * **idx** Idx th matched row (start from 1 or -1). If positive, count from first row of window; if negative, count from last row of window; 0 is invalid, results NULL. 
  * **cond** Match expression of the row.


**Since**:
0.8.0



Example:

```sql

select col1, cond, gp, nth_value_where(col1, 2, cond) over (partition by gp order by col1 rows between 10 preceding and current row) as agg from t1;
```


| col1    | cond    | gp    | agg     |
|  -------- | -------- | -------- | -------- |
| 1    | true    | 100    | NULL     |
| 2    | false    | 100    | NULL     |
| 3    | NULL    | 100    | NULL     |
| 4    | true    | 100    | 4    |



**Supported Types**:

* [`list<bool>`, `list<int16>`, `list<bool>`]
* [`list<bool>`, `list<int32>`, `list<bool>`]
* [`list<bool>`, `list<int64>`, `list<bool>`]
* [`list<date>`, `list<int16>`, `list<bool>`]
* [`list<date>`, `list<int32>`, `list<bool>`]
* [`list<date>`, `list<int64>`, `list<bool>`]
* [`list<number>`, `list<int16>`, `list<bool>`]
* [`list<number>`, `list<int32>`, `list<bool>`]
* [`list<number>`, `list<int64>`, `list<bool>`]
* [`list<string>`, `list<int16>`, `list<bool>`]
* [`list<string>`, `list<int32>`, `list<bool>`]
* [`list<string>`, `list<int64>`, `list<bool>`]
* [`list<timestamp>`, `list<int16>`, `list<bool>`]
* [`list<timestamp>`, `list<int32>`, `list<bool>`]
* [`list<timestamp>`, `list<int64>`, `list<bool>`] 

### function nvl

```cpp
nvl()
```

**Description**:


alias to if_null 

### function nvl2

```cpp
nvl2()
```

**Description**:

nvl2(expr1, expr2, expr3) - Returns expr2 if expr1 is not null, or expr3 otherwise. 

**Parameters**: 

  * **expr1** Condition expression 
  * **expr2** Return value if expr1 is not null 
  * **expr3** Return value if expr1 is null


**Since**:
0.2.3


Example:

```sql

SELECT nvl2(NULL, 2, 1);
-- output 1
```


**Supported Types**:

* [`any`, `any`, `any`] 

### function pmod

```cpp
pmod()
```

**Description**:

Compute pmod of two arguments. If any param is NULL, output NULL. If divisor is 0, output NULL. 

**Parameters**: 

  * **dividend** any numeric number or NULL 
  * **divisor** any numeric number or NULL


**Since**:
0.7.0



Example:

```sql

select pmod(-10, 3);
-- output 2
select pmod(10, -3);
-- output 1
select pmod(10, 3);
-- output 1
select pmod(-10, 0);
-- output NULL
select pmod(-10, NULL);
-- output NULL
select pmod(NULL, 2);
-- output NULL
```


**Supported Types**:

* [`bool`, `bool`]
* [`bool`, `number`]
* [`number`, `bool`]
* [`number`, `number`] 

### function pow

```cpp
pow()
```

**Description**:

Return the value of expr1 to the power of expr2. 

**Parameters**: 

  * **expr1** 
  * **expr2** 


**Since**:
0.1.0


Example:

```sql

SELECT POW(2, 10);
-- output 1024.000000
```


**Supported Types**:

* [`bool`, `bool`]
* [`bool`, `number`]
* [`number`, `bool`]
* [`number`, `number`] 

### function power

```cpp
power()
```

**Description**:


alias to pow 

### function radians

```cpp
radians()
```

**Description**:

Returns the argument X, converted from degrees to radians. (Note that Ï€ radians equals 180 degrees.) 

**Since**:
0.6.0


Example:

```sql

SELECT RADIANS(90.0);
--output 1.570796326794896619231
```


**Supported Types**:

* [`number`] 

### function regexp_like

```cpp
regexp_like()
```

**Description**:

pattern match same as RLIKE predicate (based on RE2) 

**Parameters**: 

  * **target** string to match
  * **pattern** the regular expression match pattern


**Since**:
0.6.1


Rules:

1. Accept standard POSIX (egrep) syntax regular expressions
    * dot (.) : matches any single-width ASCII character in an expression, with the exception of line break characters.
    * asterisk (*) : matches the preceding token zero or more times.
    * plus sign (+) : matches the preceding token one or more times.
    * question mark (?) : identifies the preceding character as being optional.
    * vertical bar (|) : separates tokens, one of which must be matched, much like a logical OR statement.
    * parenthesis ('(' and ')') : groups multiple tokens together to disambiguate or simplify references to them.
    * open square bracket ([) and close square bracket (]) : enclose specific characters or a range of characters to be matched. The characters enclosed inside square brackets are known as a character class.
    * caret (^) : the caret has two different meanings in a regular expression, depending on where it appears: As the first character in a character class, a caret negates the characters in that character class. As the first character in a regular expression, a caret identifies the beginning of a term. In this context, the caret is often referred to as an anchor character.
    * dollar sign ($) : as the last character in a regular expression, a dollar sign identifies the end of a term. In this context, the dollar sign is often referred to as an anchor character.
    * backslash () : used to invoke the actual character value for a metacharacter in a regular expression.
2. case sensitive
3. backslash: sql string literal use backslash() for escape sequences, write '\' as backslash itself
4. Return NULL if target or pattern is NULL

Example:

```sql

select regexp_like('Mike', 'Mi.k')
-- output: true

select regexp_like('append', 'ap*end')
-- output: true
```


**Supported Types**:

* [`string`, `string`]
* [`string`, `string`, `string`] 

### function replace

```cpp
replace()
```

**Description**:

replace(str, search[, replace]) - Replaces all occurrences of `search` with `replace`

**Since**:
0.5.2


if replace is not given or is empty string, matched `search`s removed from final string

Example:

```sql

select replace("ABCabc", "abc")
-- output "ABC"
```


**Supported Types**:

* [`string`, `string`]
* [`string`, `string`, `string`] 

### function reverse

```cpp
reverse()
```

**Description**:

Returns the reversed given string. 

**Since**:
0.4.0


Example:

```sql

SELECT REVERSE('abc') as str1;
--output "cba"
```


**Supported Types**:

* [`string`] 

### function round

```cpp
round()
```

**Description**:

Returns expr rounded to d decimal places using HALF_UP rounding mode. 

**Parameters**: 

  * **numeric_expr** Expression evaluated to numeric 
  * **d** Integer decimal place, if omitted, default to 0


**Since**:
0.1.0



When `d` is a positive, `numeric_expr` is rounded to the number of decimal positions specified by `d`. When `d` is a negative , `numeric_expr` is rounded on the left side of the decimal point. Return type is the same as the type first parameter.

Example:

```sql

SELECT round(1.23);
-- 1 (double type)

SELECT round(1.23, 1)
-- 1.2 (double type)

SELECT round(123, -1)
-- 120 (int32 type)
```


**Supported Types**:

* [`number`, ...]
* [`number`, `int32`] 

### function second

```cpp
second()
```

**Description**:

Return the second for a timestamp. 

**Since**:
0.1.0


Example:

```sql

select second(timestamp(1590115420000));
-- output 40
```


**Supported Types**:

* [`int64`]
* [`timestamp`] 

### function sin

```cpp
sin()
```

**Description**:

Return the sine of expr. 

**Parameters**: 

  * **expr** It is a single argument in radians.


**Since**:
0.1.0


Example:

```sql

SELECT SIN(0);
-- output 0.000000
```



* The value returned by [sin()](/openmldb_sql/functions_and_operators/Files/udfs_8h.md#function-sin) is always in the range: -1 to 1.


**Supported Types**:

* [`number`] 

### function size

```cpp
size()
```

**Description**:

Get the size of a List (e.g., result of split) 

**Since**:
0.7.0


Example:

```sql

select size(split("a b c", " "));
-- output 3
```


**Supported Types**:

* [`list<string>`] 

### function split

```cpp
split()
```

**Description**:

Split string to list by delimeter. Null values are skipped. 

**Parameters**: 

  * **input** Input string 
  * **delimeter** Delimeter of string


**Since**:
0.6.5



Example:

```sql

select `join`(split("k1:1,k2:2", ","), " ") as out;
-- output "k1:1 k2:2"
```


**Supported Types**:

* [`string`, `string`] 

### function split_array

```cpp
split_array()
```

**Description**:

Split string to array of string by delimeter. 

**Since**:
0.7.0


```sql

select array_contains(split_array("2,1", ","), "1") as c0;
-- output true
```


**Supported Types**:

* [`string`, `string`] 

### function split_by_key

```cpp
split_by_key()
```

**Description**:

Split string by delimeter and split each segment as kv pair, then add each key to output list. Null or illegal segments are skipped. 

**Parameters**: 

  * **input** Input string 
  * **delimeter** Delimeter of string 
  * **kv_delimeter** Delimeter of kv pair


**Since**:
0.6.5



Example:

```sql

select `join`(split_by_key("k1:1, k2:2", ",", ":"), " ") as out;
-- output "k1 k2"
```


**Supported Types**:

* [`string`, `string`, `string`] 

### function split_by_value

```cpp
split_by_value()
```

**Description**:

Split string by delimeter and split each segment as kv pair, then add each value to output list. Null or illegal segments are skipped. 

**Parameters**: 

  * **input** Input string 
  * **delimeter** Delimeter of string 
  * **kv_delimeter** Delimeter of kv pair


**Since**:
0.6.5



Example:

```sql

select `join`(split_by_value("k1:1, k2:2", ",", ":"), " ") as out;
-- output "1 2"
```


**Supported Types**:

* [`string`, `string`, `string`] 

### function sqrt

```cpp
sqrt()
```

**Description**:

Return square root of expr. 

**Parameters**: 

  * **expr** It is a single argument in radians.


**Since**:
0.1.0


Example:

```sql

SELECT SQRT(100);
-- output 10.000000
```


**Supported Types**:

* [`number`] 

### function std

```cpp
std()
```

**Description**:


alias to stddev 

### function stddev

```cpp
stddev()
```

**Description**:

Compute sample standard deviation of values, i.e., `sqrt( sum((x_i - avg)^2) / (n-1) )`

**Parameters**: 

  * **value** Specify value column to aggregate on.


**Since**:
0.7.2


Alias function: `std`, `stddev_samp`


Example:


| value     |
|  -------- |
| 1     |
| 2     |
| 3     |
| 4    |


```sql

SELECT stddev(value) OVER w;
-- output 1.290994
```


**Supported Types**:

* [`list<number>`] 

### function stddev_pop

```cpp
stddev_pop()
```

**Description**:

Compute population standard deviation of values, i.e., `sqrt( sum((x_i - avg)^2) / n )`

**Parameters**: 

  * **value** Specify value column to aggregate on.


**Since**:
0.7.2



Example:


| value     |
|  -------- |
| 1     |
| 2     |
| 3     |
| 4    |


```sql

SELECT stddev_pop(value) OVER w;
-- output 1.118034
```


**Supported Types**:

* [`list<number>`] 

### function stddev_samp

```cpp
stddev_samp()
```

**Description**:


alias to stddev 

### function strcmp

```cpp
strcmp()
```

**Description**:

Returns 0 if the strings are the same, -1 if the first argument is smaller than the second according to the current sort order, and 1 otherwise. 

**Since**:
0.1.0


Example:

```sql

select strcmp("text", "text1");
-- output -1
select strcmp("text1", "text");
-- output 1
select strcmp("text", "text");
-- output 0
```


**Supported Types**:

* [`string`, `string`] 

### function string

```cpp
string()
```

**Description**:

Return string converted from timestamp expression. 

**Since**:
0.1.0


Example:

```sql

select string(timestamp(1590115420000));
-- output "2020-05-22 10:43:40"
```


**Supported Types**:

* [`bool`]
* [`date`]
* [`number`]
* [`timestamp`] 

### function substr

```cpp
substr()
```

**Description**:


alias to substring 

### function substring

```cpp
substring()
```

**Description**:

Return a substring `len` characters long from string str, starting at position `pos`. Alias function: `substr`

**Parameters**: 

  * **str** 
  * **pos** define the begining of the substring.
  * **len** length of substring. If len is less than 1, the result is the empty string.


**Since**:
0.1.0


Example:

```sql

select substr("hello world", 3, 6);
-- output "llo wo"
```



* If `pos` is positive, the begining of the substring is `pos` charactors from the start of string.
* If `pos` is negative, the beginning of the substring is `pos` characters from the end of the string, rather than the beginning.


**Supported Types**:

* [`string`, `int32`]
* [`string`, `int32`, `int32`] 

### function sum

```cpp
sum()
```

**Description**:

Compute sum of values. 

**Parameters**: 

  * **value** Specify value column to aggregate on.



Example:


| value     |
|  -------- |
| 0     |
| 1     |
| 2     |
| 3     |
| 4    |


```sql

SELECT sum(value) OVER w;
-- output 10
```

**Supported Types**:

* [`list<number>`]
* [`list<timestamp>`] 

### function sum_cate

```cpp
sum_cate()
```

**Description**:

Compute sum of values grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **catagory** Specify catagory column to group by.



Example:


| value    | catagory     |
|  -------- | -------- |
| 0    | x     |
| 1    | y     |
| 2    | x     |
| 3    | y     |
| 4    | x    |


```sql

SELECT sum_cate(value, catagory) OVER w;
-- output "x:6,y:4"
```

**Supported Types**:

* [`list<number>`, `list<date>`]
* [`list<number>`, `list<int16>`]
* [`list<number>`, `list<int32>`]
* [`list<number>`, `list<int64>`]
* [`list<number>`, `list<string>`]
* [`list<number>`, `list<timestamp>`] 

### function sum_cate_where

```cpp
sum_cate_where()
```

**Description**:

Compute sum of values matching specified condition grouped by category key and output string. Each group is represented as 'K:V' and separated by comma in outputs and are sorted by key in ascend order. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | false    | y     |
| 2    | false    | x     |
| 3    | true    | y     |
| 4    | true    | x    |


```sql

SELECT sum_cate_where(value, condition, category) OVER w;
-- output "x:4,y:3"
```

**Supported Types**:

* [`list<number>`, `list<bool>`, `list<date>`]
* [`list<number>`, `list<bool>`, `list<int16>`]
* [`list<number>`, `list<bool>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`] 

### function sum_where

```cpp
sum_where()
```

**Description**:

Compute sum of values match specified condition. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column.


**Since**:
0.1.0



Example:


| value     |
|  -------- |
| 0     |
| 1     |
| 2     |
| 3     |
| 4    |


```sql

SELECT sum_where(value, value > 2) OVER w;
-- output 7
```


**Supported Types**:

* [`list<number>`, `list<bool>`] 

### function tan

```cpp
tan()
```

**Description**:

Return the tangent of expr. 

**Parameters**: 

  * **expr** It is a single argument in radians.


**Since**:
0.1.0


Example:

```sql

SELECT TAN(0);
-- output 0.000000
```


**Supported Types**:

* [`number`] 

### function timestamp

```cpp
timestamp()
```

**Description**:

Cast int64, date or string expression to timestamp. 

**Since**:
0.1.0


Supported string style:

* yyyy-mm-dd
* yyyymmdd
* yyyy-mm-dd hh:mm:ss

Example:

```sql

select timestamp(1590115420000);
-- output 1590115420000

select timestamp("2020-05-22");
-- output 1590076800000

select timestamp("2020-05-22 10:43:40");
-- output 1590115420000
```


**Supported Types**:

* [`date`]
* [`string`] 

### function top

```cpp
top()
```

**Description**:

Compute top k of values and output string separated by comma. The outputs are sorted in desc order. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **k** Fetch top n keys.


**Since**:
0.1.0



Example:


| value     |
|  -------- |
| 1     |
| 2     |
| 3     |
| 4     |
| 4    |


```sql

SELECT top(value, 3) OVER w;
-- output "4,4,3"
```


**Supported Types**:

* [`list<date>`, `list<int32>`]
* [`list<date>`, `list<int64>`]
* [`list<number>`, `list<int32>`]
* [`list<number>`, `list<int64>`]
* [`list<string>`, `list<int32>`]
* [`list<string>`, `list<int64>`]
* [`list<timestamp>`, `list<int32>`]
* [`list<timestamp>`, `list<int64>`] 

### function top1_ratio

```cpp
top1_ratio()
```

**Description**:

Compute the top1 key's ratio. 

**Since**:
0.6.5



**Supported Types**:

* [`list<date>`]
* [`list<number>`]
* [`list<string>`]
* [`list<timestamp>`] 

### function top_n_key_avg_cate_where

```cpp
top_n_key_avg_cate_where()
```

**Description**:

Compute average of values matching specified condition grouped by category key. Output string for top N category keys in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by. 
  * **n** Fetch top n keys.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | false    | y     |
| 2    | false    | x     |
| 3    | true    | y     |
| 4    | true    | x     |
| 5    | true    | z     |
| 6    | false    | z    |


```sql

    SELECT top_n_key_avg_cate_where(value, condition, catagory, 2)
OVER w;
    -- output "z:5,y:3"
```

**Supported Types**:

* [`list<number>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int64>`] 

### function top_n_key_count_cate_where

```cpp
top_n_key_count_cate_where()
```

**Description**:

Compute count of values matching specified condition grouped by category key. Output string for top N category keys in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by. 
  * **n** Fetch top n keys.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | true    | y     |
| 2    | false    | x     |
| 3    | true    | y     |
| 4    | false    | x     |
| 5    | true    | z     |
| 6    | true    | z    |


```sql

    SELECT top_n_key_count_cate_where(value, condition, catagory, 2)
OVER w;
    -- output "z:2,y:2"
```

**Supported Types**:

* [`list<bool>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<bool>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<bool>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<bool>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<bool>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<bool>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<bool>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<bool>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<bool>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<bool>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<bool>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<bool>`, `list<bool>`, `list<timestamp>`, `list<int64>`]
* [`list<date>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<date>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<date>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<date>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<date>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<date>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<date>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<date>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<date>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<date>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<date>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<date>`, `list<bool>`, `list<timestamp>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int64>`]
* [`list<string>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<string>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<string>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<string>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<string>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<string>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<string>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<string>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<string>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<string>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<string>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<string>`, `list<bool>`, `list<timestamp>`, `list<int64>`]
* [`list<timestamp>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<timestamp>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<timestamp>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<timestamp>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<timestamp>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<timestamp>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<timestamp>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<timestamp>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<timestamp>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<timestamp>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<timestamp>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<timestamp>`, `list<bool>`, `list<timestamp>`, `list<int64>`] 

### function top_n_key_max_cate_where

```cpp
top_n_key_max_cate_where()
```

**Description**:

Compute maximum of values matching specified condition grouped by category key. Output string for top N category keys in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by. 
  * **n** Fetch top n keys.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | false    | y     |
| 2    | false    | x     |
| 3    | true    | y     |
| 4    | true    | x     |
| 5    | true    | z     |
| 6    | false    | z    |


```sql

    SELECT top_n_key_max_cate_where(value, condition, catagory, 2)
OVER w;
    -- output "z:5,y:3"
```

**Supported Types**:

* [`list<number>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int64>`] 

### function top_n_key_min_cate_where

```cpp
top_n_key_min_cate_where()
```

**Description**:

Compute minimum of values matching specified condition grouped by category key. Output string for top N category keys in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by. 
  * **n** Fetch top n keys.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | true    | y     |
| 2    | false    | x     |
| 3    | true    | y     |
| 4    | false    | x     |
| 5    | true    | z     |
| 6    | true    | z    |


```sql

    SELECT top_n_key_min_cate_where(value, condition, catagory, 2)
OVER w;
    -- output "z:5,y:1"
```

**Supported Types**:

* [`list<number>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int64>`] 

### function top_n_key_sum_cate_where

```cpp
top_n_key_sum_cate_where()
```

**Description**:

Compute sum of values matching specified condition grouped by category key. Output string for top N category keys in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by. 
  * **n** Fetch top n keys.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | true    | y     |
| 2    | false    | x     |
| 3    | true    | y     |
| 4    | false    | x     |
| 5    | true    | z     |
| 6    | true    | z    |


```sql

    SELECT top_n_key_sum_cate_where(value, condition, catagory, 2)
OVER w;
    -- output "z:11,y:4"
```

**Supported Types**:

* [`list<number>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int64>`] 

### function top_n_value_avg_cate_where

```cpp
top_n_value_avg_cate_where()
```

**Description**:

Compute average of values matching specified condition grouped by category key. Output string for top N aggregate values in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by. 
  * **n** Fetch top n keys.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | false    | y     |
| 2    | false    | x     |
| 3    | false    | y     |
| 4    | true    | x     |
| 5    | true    | z     |
| 6    | false    | z    |


```sql

    SELECT top_n_value_avg_cate_where(value, condition, catagory, 2)
OVER w;
    -- output "z:5,x:4"
```

**Supported Types**:

* [`list<number>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int64>`] 

### function top_n_value_count_cate_where

```cpp
top_n_value_count_cate_where()
```

**Description**:

Compute count of values matching specified condition grouped by category key. Output string for top N aggregate values in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by. 
  * **n** Top N.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | true    | y     |
| 2    | true    | x     |
| 3    | false    | y     |
| 4    | true    | x     |
| 5    | true    | z     |
| 6    | true    | z    |


```sql

    SELECT top_n_value_count_cate_where(value, condition, catagory, 2)
OVER w;
    -- output "x:3,y:2"
```

**Supported Types**:

* [`list<bool>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<bool>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<bool>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<bool>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<bool>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<bool>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<bool>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<bool>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<bool>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<bool>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<bool>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<bool>`, `list<bool>`, `list<timestamp>`, `list<int64>`]
* [`list<date>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<date>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<date>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<date>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<date>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<date>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<date>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<date>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<date>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<date>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<date>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<date>`, `list<bool>`, `list<timestamp>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int64>`]
* [`list<string>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<string>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<string>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<string>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<string>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<string>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<string>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<string>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<string>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<string>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<string>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<string>`, `list<bool>`, `list<timestamp>`, `list<int64>`]
* [`list<timestamp>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<timestamp>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<timestamp>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<timestamp>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<timestamp>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<timestamp>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<timestamp>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<timestamp>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<timestamp>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<timestamp>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<timestamp>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<timestamp>`, `list<bool>`, `list<timestamp>`, `list<int64>`] 

### function top_n_value_max_cate_where

```cpp
top_n_value_max_cate_where()
```

**Description**:

Compute maximum of values matching specified condition grouped by category key. Output string for top N aggregate values in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by. 
  * **n** Fetch Top n.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | false    | y     |
| 2    | false    | x     |
| 3    | true    | y     |
| 4    | true    | x     |
| 5    | true    | z     |
| 6    | false    | z    |


```sql

    SELECT top_n_value_max_cate_where(value, condition, catagory, 2)
OVER w;
    -- output "z:5,x:4"
```

**Supported Types**:

* [`list<number>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int64>`] 

### function top_n_value_min_cate_where

```cpp
top_n_value_min_cate_where()
```

**Description**:

Compute minimum of values matching specified condition grouped by category key. Output string for top N aggregate values in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by. 
  * **n** Fetch top n keys.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | true    | y     |
| 2    | true    | x     |
| 3    | true    | y     |
| 4    | false    | x     |
| 5    | true    | z     |
| 6    | true    | z    |


```sql

    SELECT top_n_value_min_cate_where(value, condition, catagory, 2)
OVER w;
    -- output "z:5,x:2"
```

**Supported Types**:

* [`list<number>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int64>`] 

### function top_n_value_sum_cate_where

```cpp
top_n_value_sum_cate_where()
```

**Description**:

Compute sum of values matching specified condition grouped by category key. Output string for top N aggregate values in descend order. Each group is represented as 'K:V' and separated by comma(,). Empty string returned if no rows selected. 

**Parameters**: 

  * **value** Specify value column to aggregate on. 
  * **condition** Specify condition column. 
  * **catagory** Specify catagory column to group by. 
  * **n** Top N.



Example:


| value    | condition    | catagory     |
|  -------- | -------- | -------- |
| 0    | true    | x     |
| 1    | true    | y     |
| 2    | false    | x     |
| 3    | false    | y     |
| 4    | true    | x     |
| 5    | true    | z     |
| 6    | true    | z    |


```sql

    SELECT top_n_value_sum_cate_where(value, condition, catagory, 2)
OVER w;
    -- output "z:11,x:4"
```

**Supported Types**:

* [`list<number>`, `list<bool>`, `list<date>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<date>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int16>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int32>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<int64>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<string>`, `list<int64>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int32>`]
* [`list<number>`, `list<bool>`, `list<timestamp>`, `list<int64>`] 

### function topn_frequency

```cpp
topn_frequency()
```

**Description**:

Return the topN keys sorted by their frequency. 

**Since**:
0.6.5



**Supported Types**:

* [`list<date>`, `list<int32>`]
* [`list<number>`, `list<int32>`]
* [`list<string>`, `list<int32>`]
* [`list<timestamp>`, `list<int32>`] 

### function truncate

```cpp
truncate()
```

**Description**:

Return the nearest integer that is not greater in magnitude than the expr. 

**Parameters**: 

  * **expr** 


**Since**:
0.1.0


Example:

```sql

SELECT TRUNCATE(1.23);
-- output 1.0
```


**Supported Types**:

* [`bool`]
* [`number`] 

### function ucase

```cpp
ucase()
```

**Description**:

Convert all the characters to uppercase. Note that characters values > 127 are simply returned. 

**Since**:
0.4.0


Example:

```sql

SELECT UCASE('Sql') as str1;
--output "SQL"
```


**Supported Types**:

* [`string`] 

### function unhex

```cpp
unhex()
```

**Description**:

Convert hexadecimal to binary string. 

**Since**:
0.7.0


Example:

```sql

select unhex("537061726B2053514C");
--output "Spark SQL"

select unhex("7B");
--output "{"

select unhex("zfk");
--output NULL
```


**Supported Types**:

* [`string`] 

### function unix_timestamp

```cpp
unix_timestamp()
```

**Description**:

Cast date or string expression to unix_timestamp. If empty string or NULL is provided, return current timestamp. 

**Since**:
0.7.0


Supported string style:

* yyyy-mm-dd
* yyyymmdd
* yyyy-mm-dd hh:mm:ss

Example:

```sql

select unix_timestamp("2020-05-22");
-- output 1590076800

select unix_timestamp("2020-05-22 10:43:40");
-- output 1590115420

select unix_timestamp("");
-- output 1670404338 (the current timestamp)
```


**Supported Types**:

* [`date`]
* [`string`] 

### function upper

```cpp
upper()
```

**Description**:


alias to ucase 

### function var_pop

```cpp
var_pop()
```

**Description**:

Compute population variance of values, i.e., `sum((x_i - avg)^2) / n`

**Parameters**: 

  * **value** Specify value column to aggregate on.


**Since**:
0.8.0



Example:


| value     |
|  -------- |
| 0     |
| 3     |
| 6    |


```sql

SELECT var_pop(value) OVER w;
-- output 6.0
```


**Supported Types**:

* [`list<number>`] 

### function var_samp

```cpp
var_samp()
```

**Description**:

Compute population variance of values, i.e., `sum((x_i - avg)^2) / (n-1)`

**Parameters**: 

  * **value** Specify value column to aggregate on.


**Since**:
0.8.0



Example:


| value     |
|  -------- |
| 0     |
| 3     |
| 6    |


```sql

SELECT var_samp(value) OVER w;
-- output 9.0
```


**Supported Types**:

* [`list<number>`] 

### function variance

```cpp
variance()
```

**Description**:


alias to var_samp 

### function week

```cpp
week()
```

**Description**:


alias to weekofyear 

### function weekofyear

```cpp
weekofyear()
```

**Description**:

Return the week of year for a timestamp or date. 

**Since**:
0.1.0


Example:

```sql

select weekofyear(timestamp(1590115420000));
-- output 21
select week(timestamp(1590115420000));
-- output 21
```


**Supported Types**:

* [`date`]
* [`int64`]
* [`timestamp`] 

### function window_split

```cpp
window_split()
```

**Description**:

For each string value from specified column of window, split by delimeter and add segment to output list. Null values are skipped. 

**Since**:
0.6.5



**Supported Types**:

* [`list<string>`, `list<string>`] 

### function window_split_by_key

```cpp
window_split_by_key()
```

**Description**:

For each string value from specified column of window, split by delimeter and then split each segment as kv pair, then add each key to output list. Null and illegal segments are skipped. 

**Since**:
0.6.5



**Supported Types**:

* [`list<string>`, `list<string>`, `list<string>`] 

### function window_split_by_value

```cpp
window_split_by_value()
```

**Description**:

For each string value from specified column of window, split by delimeter and then split each segment as kv pair, then add each value to output list. Null and illegal segments are skipped. 

**Since**:
0.6.5



**Supported Types**:

* [`list<string>`, `list<string>`, `list<string>`] 

### function year

```cpp
year()
```

**Description**:

Return the year part of a timestamp or date. 

**Since**:
0.1.0


Example:

```sql

select year(timestamp(1590115420000));
-- output 2020
```


**Supported Types**:

* [`date`]
* [`int64`]
* [`timestamp`] 




