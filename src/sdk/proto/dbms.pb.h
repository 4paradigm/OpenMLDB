// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dbms.proto

#ifndef PROTOBUF_INCLUDED_dbms_2eproto
#define PROTOBUF_INCLUDED_dbms_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "fe_common.pb.h"
#include "fe_type.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_dbms_2eproto 

namespace protobuf_dbms_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[18];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_dbms_2eproto
namespace hybridse {
namespace dbms {
class AddDatabaseRequest;
class AddDatabaseRequestDefaultTypeInternal;
extern AddDatabaseRequestDefaultTypeInternal _AddDatabaseRequest_default_instance_;
class AddDatabaseResponse;
class AddDatabaseResponseDefaultTypeInternal;
extern AddDatabaseResponseDefaultTypeInternal _AddDatabaseResponse_default_instance_;
class AddGroupRequest;
class AddGroupRequestDefaultTypeInternal;
extern AddGroupRequestDefaultTypeInternal _AddGroupRequest_default_instance_;
class AddGroupResponse;
class AddGroupResponseDefaultTypeInternal;
extern AddGroupResponseDefaultTypeInternal _AddGroupResponse_default_instance_;
class AddTableRequest;
class AddTableRequestDefaultTypeInternal;
extern AddTableRequestDefaultTypeInternal _AddTableRequest_default_instance_;
class AddTableResponse;
class AddTableResponseDefaultTypeInternal;
extern AddTableResponseDefaultTypeInternal _AddTableResponse_default_instance_;
class GetDatabasesRequest;
class GetDatabasesRequestDefaultTypeInternal;
extern GetDatabasesRequestDefaultTypeInternal _GetDatabasesRequest_default_instance_;
class GetDatabasesResponse;
class GetDatabasesResponseDefaultTypeInternal;
extern GetDatabasesResponseDefaultTypeInternal _GetDatabasesResponse_default_instance_;
class GetSchemaRequest;
class GetSchemaRequestDefaultTypeInternal;
extern GetSchemaRequestDefaultTypeInternal _GetSchemaRequest_default_instance_;
class GetSchemaResponse;
class GetSchemaResponseDefaultTypeInternal;
extern GetSchemaResponseDefaultTypeInternal _GetSchemaResponse_default_instance_;
class GetTablesRequest;
class GetTablesRequestDefaultTypeInternal;
extern GetTablesRequestDefaultTypeInternal _GetTablesRequest_default_instance_;
class GetTablesResponse;
class GetTablesResponseDefaultTypeInternal;
extern GetTablesResponseDefaultTypeInternal _GetTablesResponse_default_instance_;
class GetTabletRequest;
class GetTabletRequestDefaultTypeInternal;
extern GetTabletRequestDefaultTypeInternal _GetTabletRequest_default_instance_;
class GetTabletResponse;
class GetTabletResponseDefaultTypeInternal;
extern GetTabletResponseDefaultTypeInternal _GetTabletResponse_default_instance_;
class IsExistRequest;
class IsExistRequestDefaultTypeInternal;
extern IsExistRequestDefaultTypeInternal _IsExistRequest_default_instance_;
class IsExistResponse;
class IsExistResponseDefaultTypeInternal;
extern IsExistResponseDefaultTypeInternal _IsExistResponse_default_instance_;
class KeepAliveRequest;
class KeepAliveRequestDefaultTypeInternal;
extern KeepAliveRequestDefaultTypeInternal _KeepAliveRequest_default_instance_;
class KeepAliveResponse;
class KeepAliveResponseDefaultTypeInternal;
extern KeepAliveResponseDefaultTypeInternal _KeepAliveResponse_default_instance_;
}  // namespace dbms
}  // namespace hybridse
namespace google {
namespace protobuf {
template<> ::hybridse::dbms::AddDatabaseRequest* Arena::CreateMaybeMessage<::hybridse::dbms::AddDatabaseRequest>(Arena*);
template<> ::hybridse::dbms::AddDatabaseResponse* Arena::CreateMaybeMessage<::hybridse::dbms::AddDatabaseResponse>(Arena*);
template<> ::hybridse::dbms::AddGroupRequest* Arena::CreateMaybeMessage<::hybridse::dbms::AddGroupRequest>(Arena*);
template<> ::hybridse::dbms::AddGroupResponse* Arena::CreateMaybeMessage<::hybridse::dbms::AddGroupResponse>(Arena*);
template<> ::hybridse::dbms::AddTableRequest* Arena::CreateMaybeMessage<::hybridse::dbms::AddTableRequest>(Arena*);
template<> ::hybridse::dbms::AddTableResponse* Arena::CreateMaybeMessage<::hybridse::dbms::AddTableResponse>(Arena*);
template<> ::hybridse::dbms::GetDatabasesRequest* Arena::CreateMaybeMessage<::hybridse::dbms::GetDatabasesRequest>(Arena*);
template<> ::hybridse::dbms::GetDatabasesResponse* Arena::CreateMaybeMessage<::hybridse::dbms::GetDatabasesResponse>(Arena*);
template<> ::hybridse::dbms::GetSchemaRequest* Arena::CreateMaybeMessage<::hybridse::dbms::GetSchemaRequest>(Arena*);
template<> ::hybridse::dbms::GetSchemaResponse* Arena::CreateMaybeMessage<::hybridse::dbms::GetSchemaResponse>(Arena*);
template<> ::hybridse::dbms::GetTablesRequest* Arena::CreateMaybeMessage<::hybridse::dbms::GetTablesRequest>(Arena*);
template<> ::hybridse::dbms::GetTablesResponse* Arena::CreateMaybeMessage<::hybridse::dbms::GetTablesResponse>(Arena*);
template<> ::hybridse::dbms::GetTabletRequest* Arena::CreateMaybeMessage<::hybridse::dbms::GetTabletRequest>(Arena*);
template<> ::hybridse::dbms::GetTabletResponse* Arena::CreateMaybeMessage<::hybridse::dbms::GetTabletResponse>(Arena*);
template<> ::hybridse::dbms::IsExistRequest* Arena::CreateMaybeMessage<::hybridse::dbms::IsExistRequest>(Arena*);
template<> ::hybridse::dbms::IsExistResponse* Arena::CreateMaybeMessage<::hybridse::dbms::IsExistResponse>(Arena*);
template<> ::hybridse::dbms::KeepAliveRequest* Arena::CreateMaybeMessage<::hybridse::dbms::KeepAliveRequest>(Arena*);
template<> ::hybridse::dbms::KeepAliveResponse* Arena::CreateMaybeMessage<::hybridse::dbms::KeepAliveResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hybridse {
namespace dbms {

// ===================================================================

class AddGroupRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.AddGroupRequest) */ {
 public:
  AddGroupRequest();
  virtual ~AddGroupRequest();

  AddGroupRequest(const AddGroupRequest& from);

  inline AddGroupRequest& operator=(const AddGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddGroupRequest(AddGroupRequest&& from) noexcept
    : AddGroupRequest() {
    *this = ::std::move(from);
  }

  inline AddGroupRequest& operator=(AddGroupRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddGroupRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddGroupRequest* internal_default_instance() {
    return reinterpret_cast<const AddGroupRequest*>(
               &_AddGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(AddGroupRequest* other);
  friend void swap(AddGroupRequest& a, AddGroupRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddGroupRequest* New() const final {
    return CreateMaybeMessage<AddGroupRequest>(NULL);
  }

  AddGroupRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddGroupRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddGroupRequest& from);
  void MergeFrom(const AddGroupRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddGroupRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.AddGroupRequest)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddGroupResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.AddGroupResponse) */ {
 public:
  AddGroupResponse();
  virtual ~AddGroupResponse();

  AddGroupResponse(const AddGroupResponse& from);

  inline AddGroupResponse& operator=(const AddGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddGroupResponse(AddGroupResponse&& from) noexcept
    : AddGroupResponse() {
    *this = ::std::move(from);
  }

  inline AddGroupResponse& operator=(AddGroupResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddGroupResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddGroupResponse* internal_default_instance() {
    return reinterpret_cast<const AddGroupResponse*>(
               &_AddGroupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(AddGroupResponse* other);
  friend void swap(AddGroupResponse& a, AddGroupResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddGroupResponse* New() const final {
    return CreateMaybeMessage<AddGroupResponse>(NULL);
  }

  AddGroupResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddGroupResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddGroupResponse& from);
  void MergeFrom(const AddGroupResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddGroupResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hybridse.common.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::hybridse::common::Status& _internal_status() const;
  public:
  const ::hybridse::common::Status& status() const;
  ::hybridse::common::Status* release_status();
  ::hybridse::common::Status* mutable_status();
  void set_allocated_status(::hybridse::common::Status* status);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.AddGroupResponse)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hybridse::common::Status* status_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddDatabaseRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.AddDatabaseRequest) */ {
 public:
  AddDatabaseRequest();
  virtual ~AddDatabaseRequest();

  AddDatabaseRequest(const AddDatabaseRequest& from);

  inline AddDatabaseRequest& operator=(const AddDatabaseRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddDatabaseRequest(AddDatabaseRequest&& from) noexcept
    : AddDatabaseRequest() {
    *this = ::std::move(from);
  }

  inline AddDatabaseRequest& operator=(AddDatabaseRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddDatabaseRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddDatabaseRequest* internal_default_instance() {
    return reinterpret_cast<const AddDatabaseRequest*>(
               &_AddDatabaseRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AddDatabaseRequest* other);
  friend void swap(AddDatabaseRequest& a, AddDatabaseRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddDatabaseRequest* New() const final {
    return CreateMaybeMessage<AddDatabaseRequest>(NULL);
  }

  AddDatabaseRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddDatabaseRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddDatabaseRequest& from);
  void MergeFrom(const AddDatabaseRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddDatabaseRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.AddDatabaseRequest)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddDatabaseResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.AddDatabaseResponse) */ {
 public:
  AddDatabaseResponse();
  virtual ~AddDatabaseResponse();

  AddDatabaseResponse(const AddDatabaseResponse& from);

  inline AddDatabaseResponse& operator=(const AddDatabaseResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddDatabaseResponse(AddDatabaseResponse&& from) noexcept
    : AddDatabaseResponse() {
    *this = ::std::move(from);
  }

  inline AddDatabaseResponse& operator=(AddDatabaseResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddDatabaseResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddDatabaseResponse* internal_default_instance() {
    return reinterpret_cast<const AddDatabaseResponse*>(
               &_AddDatabaseResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AddDatabaseResponse* other);
  friend void swap(AddDatabaseResponse& a, AddDatabaseResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddDatabaseResponse* New() const final {
    return CreateMaybeMessage<AddDatabaseResponse>(NULL);
  }

  AddDatabaseResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddDatabaseResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddDatabaseResponse& from);
  void MergeFrom(const AddDatabaseResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddDatabaseResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hybridse.common.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::hybridse::common::Status& _internal_status() const;
  public:
  const ::hybridse::common::Status& status() const;
  ::hybridse::common::Status* release_status();
  ::hybridse::common::Status* mutable_status();
  void set_allocated_status(::hybridse::common::Status* status);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.AddDatabaseResponse)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hybridse::common::Status* status_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsExistRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.IsExistRequest) */ {
 public:
  IsExistRequest();
  virtual ~IsExistRequest();

  IsExistRequest(const IsExistRequest& from);

  inline IsExistRequest& operator=(const IsExistRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsExistRequest(IsExistRequest&& from) noexcept
    : IsExistRequest() {
    *this = ::std::move(from);
  }

  inline IsExistRequest& operator=(IsExistRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsExistRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsExistRequest* internal_default_instance() {
    return reinterpret_cast<const IsExistRequest*>(
               &_IsExistRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(IsExistRequest* other);
  friend void swap(IsExistRequest& a, IsExistRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsExistRequest* New() const final {
    return CreateMaybeMessage<IsExistRequest>(NULL);
  }

  IsExistRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IsExistRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IsExistRequest& from);
  void MergeFrom(const IsExistRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsExistRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.IsExistRequest)
 private:
  void set_has_name();
  void clear_has_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IsExistResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.IsExistResponse) */ {
 public:
  IsExistResponse();
  virtual ~IsExistResponse();

  IsExistResponse(const IsExistResponse& from);

  inline IsExistResponse& operator=(const IsExistResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IsExistResponse(IsExistResponse&& from) noexcept
    : IsExistResponse() {
    *this = ::std::move(from);
  }

  inline IsExistResponse& operator=(IsExistResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IsExistResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IsExistResponse* internal_default_instance() {
    return reinterpret_cast<const IsExistResponse*>(
               &_IsExistResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(IsExistResponse* other);
  friend void swap(IsExistResponse& a, IsExistResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IsExistResponse* New() const final {
    return CreateMaybeMessage<IsExistResponse>(NULL);
  }

  IsExistResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IsExistResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IsExistResponse& from);
  void MergeFrom(const IsExistResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IsExistResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hybridse.common.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::hybridse::common::Status& _internal_status() const;
  public:
  const ::hybridse::common::Status& status() const;
  ::hybridse::common::Status* release_status();
  ::hybridse::common::Status* mutable_status();
  void set_allocated_status(::hybridse::common::Status* status);

  // optional bool exist = 2;
  bool has_exist() const;
  void clear_exist();
  static const int kExistFieldNumber = 2;
  bool exist() const;
  void set_exist(bool value);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.IsExistResponse)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_exist();
  void clear_has_exist();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hybridse::common::Status* status_;
  bool exist_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddTableRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.AddTableRequest) */ {
 public:
  AddTableRequest();
  virtual ~AddTableRequest();

  AddTableRequest(const AddTableRequest& from);

  inline AddTableRequest& operator=(const AddTableRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddTableRequest(AddTableRequest&& from) noexcept
    : AddTableRequest() {
    *this = ::std::move(from);
  }

  inline AddTableRequest& operator=(AddTableRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddTableRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddTableRequest* internal_default_instance() {
    return reinterpret_cast<const AddTableRequest*>(
               &_AddTableRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(AddTableRequest* other);
  friend void swap(AddTableRequest& a, AddTableRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddTableRequest* New() const final {
    return CreateMaybeMessage<AddTableRequest>(NULL);
  }

  AddTableRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddTableRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddTableRequest& from);
  void MergeFrom(const AddTableRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTableRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string db_name = 2;
  bool has_db_name() const;
  void clear_db_name();
  static const int kDbNameFieldNumber = 2;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // optional .hybridse.type.TableDef table = 1;
  bool has_table() const;
  void clear_table();
  static const int kTableFieldNumber = 1;
  private:
  const ::hybridse::type::TableDef& _internal_table() const;
  public:
  const ::hybridse::type::TableDef& table() const;
  ::hybridse::type::TableDef* release_table();
  ::hybridse::type::TableDef* mutable_table();
  void set_allocated_table(::hybridse::type::TableDef* table);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.AddTableRequest)
 private:
  void set_has_table();
  void clear_has_table();
  void set_has_db_name();
  void clear_has_db_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::hybridse::type::TableDef* table_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddTableResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.AddTableResponse) */ {
 public:
  AddTableResponse();
  virtual ~AddTableResponse();

  AddTableResponse(const AddTableResponse& from);

  inline AddTableResponse& operator=(const AddTableResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddTableResponse(AddTableResponse&& from) noexcept
    : AddTableResponse() {
    *this = ::std::move(from);
  }

  inline AddTableResponse& operator=(AddTableResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddTableResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddTableResponse* internal_default_instance() {
    return reinterpret_cast<const AddTableResponse*>(
               &_AddTableResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(AddTableResponse* other);
  friend void swap(AddTableResponse& a, AddTableResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddTableResponse* New() const final {
    return CreateMaybeMessage<AddTableResponse>(NULL);
  }

  AddTableResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddTableResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddTableResponse& from);
  void MergeFrom(const AddTableResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTableResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hybridse.common.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::hybridse::common::Status& _internal_status() const;
  public:
  const ::hybridse::common::Status& status() const;
  ::hybridse::common::Status* release_status();
  ::hybridse::common::Status* mutable_status();
  void set_allocated_status(::hybridse::common::Status* status);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.AddTableResponse)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hybridse::common::Status* status_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSchemaRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.GetSchemaRequest) */ {
 public:
  GetSchemaRequest();
  virtual ~GetSchemaRequest();

  GetSchemaRequest(const GetSchemaRequest& from);

  inline GetSchemaRequest& operator=(const GetSchemaRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSchemaRequest(GetSchemaRequest&& from) noexcept
    : GetSchemaRequest() {
    *this = ::std::move(from);
  }

  inline GetSchemaRequest& operator=(GetSchemaRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSchemaRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSchemaRequest* internal_default_instance() {
    return reinterpret_cast<const GetSchemaRequest*>(
               &_GetSchemaRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GetSchemaRequest* other);
  friend void swap(GetSchemaRequest& a, GetSchemaRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSchemaRequest* New() const final {
    return CreateMaybeMessage<GetSchemaRequest>(NULL);
  }

  GetSchemaRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSchemaRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSchemaRequest& from);
  void MergeFrom(const GetSchemaRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSchemaRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string db_name = 2;
  bool has_db_name() const;
  void clear_db_name();
  static const int kDbNameFieldNumber = 2;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.GetSchemaRequest)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_db_name();
  void clear_has_db_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSchemaResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.GetSchemaResponse) */ {
 public:
  GetSchemaResponse();
  virtual ~GetSchemaResponse();

  GetSchemaResponse(const GetSchemaResponse& from);

  inline GetSchemaResponse& operator=(const GetSchemaResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSchemaResponse(GetSchemaResponse&& from) noexcept
    : GetSchemaResponse() {
    *this = ::std::move(from);
  }

  inline GetSchemaResponse& operator=(GetSchemaResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSchemaResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSchemaResponse* internal_default_instance() {
    return reinterpret_cast<const GetSchemaResponse*>(
               &_GetSchemaResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetSchemaResponse* other);
  friend void swap(GetSchemaResponse& a, GetSchemaResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSchemaResponse* New() const final {
    return CreateMaybeMessage<GetSchemaResponse>(NULL);
  }

  GetSchemaResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSchemaResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSchemaResponse& from);
  void MergeFrom(const GetSchemaResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSchemaResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hybridse.common.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::hybridse::common::Status& _internal_status() const;
  public:
  const ::hybridse::common::Status& status() const;
  ::hybridse::common::Status* release_status();
  ::hybridse::common::Status* mutable_status();
  void set_allocated_status(::hybridse::common::Status* status);

  // optional .hybridse.type.TableDef table = 2;
  bool has_table() const;
  void clear_table();
  static const int kTableFieldNumber = 2;
  private:
  const ::hybridse::type::TableDef& _internal_table() const;
  public:
  const ::hybridse::type::TableDef& table() const;
  ::hybridse::type::TableDef* release_table();
  ::hybridse::type::TableDef* mutable_table();
  void set_allocated_table(::hybridse::type::TableDef* table);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.GetSchemaResponse)
 private:
  void set_has_status();
  void clear_has_status();
  void set_has_table();
  void clear_has_table();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hybridse::common::Status* status_;
  ::hybridse::type::TableDef* table_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetDatabasesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.GetDatabasesRequest) */ {
 public:
  GetDatabasesRequest();
  virtual ~GetDatabasesRequest();

  GetDatabasesRequest(const GetDatabasesRequest& from);

  inline GetDatabasesRequest& operator=(const GetDatabasesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDatabasesRequest(GetDatabasesRequest&& from) noexcept
    : GetDatabasesRequest() {
    *this = ::std::move(from);
  }

  inline GetDatabasesRequest& operator=(GetDatabasesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDatabasesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetDatabasesRequest* internal_default_instance() {
    return reinterpret_cast<const GetDatabasesRequest*>(
               &_GetDatabasesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GetDatabasesRequest* other);
  friend void swap(GetDatabasesRequest& a, GetDatabasesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDatabasesRequest* New() const final {
    return CreateMaybeMessage<GetDatabasesRequest>(NULL);
  }

  GetDatabasesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetDatabasesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetDatabasesRequest& from);
  void MergeFrom(const GetDatabasesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDatabasesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hybridse.dbms.GetDatabasesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetDatabasesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.GetDatabasesResponse) */ {
 public:
  GetDatabasesResponse();
  virtual ~GetDatabasesResponse();

  GetDatabasesResponse(const GetDatabasesResponse& from);

  inline GetDatabasesResponse& operator=(const GetDatabasesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDatabasesResponse(GetDatabasesResponse&& from) noexcept
    : GetDatabasesResponse() {
    *this = ::std::move(from);
  }

  inline GetDatabasesResponse& operator=(GetDatabasesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDatabasesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetDatabasesResponse* internal_default_instance() {
    return reinterpret_cast<const GetDatabasesResponse*>(
               &_GetDatabasesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(GetDatabasesResponse* other);
  friend void swap(GetDatabasesResponse& a, GetDatabasesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDatabasesResponse* New() const final {
    return CreateMaybeMessage<GetDatabasesResponse>(NULL);
  }

  GetDatabasesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetDatabasesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetDatabasesResponse& from);
  void MergeFrom(const GetDatabasesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDatabasesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string names = 2;
  int names_size() const;
  void clear_names();
  static const int kNamesFieldNumber = 2;
  const ::std::string& names(int index) const;
  ::std::string* mutable_names(int index);
  void set_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_names(int index, ::std::string&& value);
  #endif
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, size_t size);
  ::std::string* add_names();
  void add_names(const ::std::string& value);
  #if LANG_CXX11
  void add_names(::std::string&& value);
  #endif
  void add_names(const char* value);
  void add_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // optional .hybridse.common.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::hybridse::common::Status& _internal_status() const;
  public:
  const ::hybridse::common::Status& status() const;
  ::hybridse::common::Status* release_status();
  ::hybridse::common::Status* mutable_status();
  void set_allocated_status(::hybridse::common::Status* status);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.GetDatabasesResponse)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> names_;
  ::hybridse::common::Status* status_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTablesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.GetTablesRequest) */ {
 public:
  GetTablesRequest();
  virtual ~GetTablesRequest();

  GetTablesRequest(const GetTablesRequest& from);

  inline GetTablesRequest& operator=(const GetTablesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTablesRequest(GetTablesRequest&& from) noexcept
    : GetTablesRequest() {
    *this = ::std::move(from);
  }

  inline GetTablesRequest& operator=(GetTablesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTablesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTablesRequest* internal_default_instance() {
    return reinterpret_cast<const GetTablesRequest*>(
               &_GetTablesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(GetTablesRequest* other);
  friend void swap(GetTablesRequest& a, GetTablesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTablesRequest* New() const final {
    return CreateMaybeMessage<GetTablesRequest>(NULL);
  }

  GetTablesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTablesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTablesRequest& from);
  void MergeFrom(const GetTablesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTablesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string db_name = 1;
  bool has_db_name() const;
  void clear_db_name();
  static const int kDbNameFieldNumber = 1;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // optional string table_name = 2;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  #if LANG_CXX11
  void set_table_name(::std::string&& value);
  #endif
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.GetTablesRequest)
 private:
  void set_has_db_name();
  void clear_has_db_name();
  void set_has_table_name();
  void clear_has_table_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTablesResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.GetTablesResponse) */ {
 public:
  GetTablesResponse();
  virtual ~GetTablesResponse();

  GetTablesResponse(const GetTablesResponse& from);

  inline GetTablesResponse& operator=(const GetTablesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTablesResponse(GetTablesResponse&& from) noexcept
    : GetTablesResponse() {
    *this = ::std::move(from);
  }

  inline GetTablesResponse& operator=(GetTablesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTablesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTablesResponse* internal_default_instance() {
    return reinterpret_cast<const GetTablesResponse*>(
               &_GetTablesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(GetTablesResponse* other);
  friend void swap(GetTablesResponse& a, GetTablesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTablesResponse* New() const final {
    return CreateMaybeMessage<GetTablesResponse>(NULL);
  }

  GetTablesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTablesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTablesResponse& from);
  void MergeFrom(const GetTablesResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTablesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hybridse.type.TableDef tables = 2;
  int tables_size() const;
  void clear_tables();
  static const int kTablesFieldNumber = 2;
  ::hybridse::type::TableDef* mutable_tables(int index);
  ::google::protobuf::RepeatedPtrField< ::hybridse::type::TableDef >*
      mutable_tables();
  const ::hybridse::type::TableDef& tables(int index) const;
  ::hybridse::type::TableDef* add_tables();
  const ::google::protobuf::RepeatedPtrField< ::hybridse::type::TableDef >&
      tables() const;

  // optional .hybridse.common.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::hybridse::common::Status& _internal_status() const;
  public:
  const ::hybridse::common::Status& status() const;
  ::hybridse::common::Status* release_status();
  ::hybridse::common::Status* mutable_status();
  void set_allocated_status(::hybridse::common::Status* status);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.GetTablesResponse)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hybridse::type::TableDef > tables_;
  ::hybridse::common::Status* status_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeepAliveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.KeepAliveRequest) */ {
 public:
  KeepAliveRequest();
  virtual ~KeepAliveRequest();

  KeepAliveRequest(const KeepAliveRequest& from);

  inline KeepAliveRequest& operator=(const KeepAliveRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeepAliveRequest(KeepAliveRequest&& from) noexcept
    : KeepAliveRequest() {
    *this = ::std::move(from);
  }

  inline KeepAliveRequest& operator=(KeepAliveRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeepAliveRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeepAliveRequest* internal_default_instance() {
    return reinterpret_cast<const KeepAliveRequest*>(
               &_KeepAliveRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(KeepAliveRequest* other);
  friend void swap(KeepAliveRequest& a, KeepAliveRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeepAliveRequest* New() const final {
    return CreateMaybeMessage<KeepAliveRequest>(NULL);
  }

  KeepAliveRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeepAliveRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeepAliveRequest& from);
  void MergeFrom(const KeepAliveRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeepAliveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string endpoint = 1;
  bool has_endpoint() const;
  void clear_endpoint();
  static const int kEndpointFieldNumber = 1;
  const ::std::string& endpoint() const;
  void set_endpoint(const ::std::string& value);
  #if LANG_CXX11
  void set_endpoint(::std::string&& value);
  #endif
  void set_endpoint(const char* value);
  void set_endpoint(const char* value, size_t size);
  ::std::string* mutable_endpoint();
  ::std::string* release_endpoint();
  void set_allocated_endpoint(::std::string* endpoint);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.KeepAliveRequest)
 private:
  void set_has_endpoint();
  void clear_has_endpoint();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr endpoint_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeepAliveResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.KeepAliveResponse) */ {
 public:
  KeepAliveResponse();
  virtual ~KeepAliveResponse();

  KeepAliveResponse(const KeepAliveResponse& from);

  inline KeepAliveResponse& operator=(const KeepAliveResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeepAliveResponse(KeepAliveResponse&& from) noexcept
    : KeepAliveResponse() {
    *this = ::std::move(from);
  }

  inline KeepAliveResponse& operator=(KeepAliveResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeepAliveResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeepAliveResponse* internal_default_instance() {
    return reinterpret_cast<const KeepAliveResponse*>(
               &_KeepAliveResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(KeepAliveResponse* other);
  friend void swap(KeepAliveResponse& a, KeepAliveResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeepAliveResponse* New() const final {
    return CreateMaybeMessage<KeepAliveResponse>(NULL);
  }

  KeepAliveResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeepAliveResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeepAliveResponse& from);
  void MergeFrom(const KeepAliveResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeepAliveResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .hybridse.common.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::hybridse::common::Status& _internal_status() const;
  public:
  const ::hybridse::common::Status& status() const;
  ::hybridse::common::Status* release_status();
  ::hybridse::common::Status* mutable_status();
  void set_allocated_status(::hybridse::common::Status* status);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.KeepAliveResponse)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::hybridse::common::Status* status_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTabletRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.GetTabletRequest) */ {
 public:
  GetTabletRequest();
  virtual ~GetTabletRequest();

  GetTabletRequest(const GetTabletRequest& from);

  inline GetTabletRequest& operator=(const GetTabletRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTabletRequest(GetTabletRequest&& from) noexcept
    : GetTabletRequest() {
    *this = ::std::move(from);
  }

  inline GetTabletRequest& operator=(GetTabletRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTabletRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTabletRequest* internal_default_instance() {
    return reinterpret_cast<const GetTabletRequest*>(
               &_GetTabletRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(GetTabletRequest* other);
  friend void swap(GetTabletRequest& a, GetTabletRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTabletRequest* New() const final {
    return CreateMaybeMessage<GetTabletRequest>(NULL);
  }

  GetTabletRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTabletRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTabletRequest& from);
  void MergeFrom(const GetTabletRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTabletRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:hybridse.dbms.GetTabletRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTabletResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.dbms.GetTabletResponse) */ {
 public:
  GetTabletResponse();
  virtual ~GetTabletResponse();

  GetTabletResponse(const GetTabletResponse& from);

  inline GetTabletResponse& operator=(const GetTabletResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTabletResponse(GetTabletResponse&& from) noexcept
    : GetTabletResponse() {
    *this = ::std::move(from);
  }

  inline GetTabletResponse& operator=(GetTabletResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTabletResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTabletResponse* internal_default_instance() {
    return reinterpret_cast<const GetTabletResponse*>(
               &_GetTabletResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(GetTabletResponse* other);
  friend void swap(GetTabletResponse& a, GetTabletResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTabletResponse* New() const final {
    return CreateMaybeMessage<GetTabletResponse>(NULL);
  }

  GetTabletResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTabletResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTabletResponse& from);
  void MergeFrom(const GetTabletResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTabletResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string endpoints = 2;
  int endpoints_size() const;
  void clear_endpoints();
  static const int kEndpointsFieldNumber = 2;
  const ::std::string& endpoints(int index) const;
  ::std::string* mutable_endpoints(int index);
  void set_endpoints(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_endpoints(int index, ::std::string&& value);
  #endif
  void set_endpoints(int index, const char* value);
  void set_endpoints(int index, const char* value, size_t size);
  ::std::string* add_endpoints();
  void add_endpoints(const ::std::string& value);
  #if LANG_CXX11
  void add_endpoints(::std::string&& value);
  #endif
  void add_endpoints(const char* value);
  void add_endpoints(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& endpoints() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_endpoints();

  // optional .hybridse.common.Status status = 1;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  private:
  const ::hybridse::common::Status& _internal_status() const;
  public:
  const ::hybridse::common::Status& status() const;
  ::hybridse::common::Status* release_status();
  ::hybridse::common::Status* mutable_status();
  void set_allocated_status(::hybridse::common::Status* status);

  // @@protoc_insertion_point(class_scope:hybridse.dbms.GetTabletResponse)
 private:
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> endpoints_;
  ::hybridse::common::Status* status_;
  friend struct ::protobuf_dbms_2eproto::TableStruct;
};
// ===================================================================

class DBMSServer_Stub;

class DBMSServer : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline DBMSServer() {};
 public:
  virtual ~DBMSServer();

  typedef DBMSServer_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void AddDatabase(::google::protobuf::RpcController* controller,
                       const ::hybridse::dbms::AddDatabaseRequest* request,
                       ::hybridse::dbms::AddDatabaseResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void AddTable(::google::protobuf::RpcController* controller,
                       const ::hybridse::dbms::AddTableRequest* request,
                       ::hybridse::dbms::AddTableResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void GetSchema(::google::protobuf::RpcController* controller,
                       const ::hybridse::dbms::GetSchemaRequest* request,
                       ::hybridse::dbms::GetSchemaResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void GetDatabases(::google::protobuf::RpcController* controller,
                       const ::hybridse::dbms::GetDatabasesRequest* request,
                       ::hybridse::dbms::GetDatabasesResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void GetTables(::google::protobuf::RpcController* controller,
                       const ::hybridse::dbms::GetTablesRequest* request,
                       ::hybridse::dbms::GetTablesResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void KeepAlive(::google::protobuf::RpcController* controller,
                       const ::hybridse::dbms::KeepAliveRequest* request,
                       ::hybridse::dbms::KeepAliveResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void GetTablet(::google::protobuf::RpcController* controller,
                       const ::hybridse::dbms::GetTabletRequest* request,
                       ::hybridse::dbms::GetTabletResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(DBMSServer);
};

class DBMSServer_Stub : public DBMSServer {
 public:
  DBMSServer_Stub(::google::protobuf::RpcChannel* channel);
  DBMSServer_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~DBMSServer_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements DBMSServer ------------------------------------------

  void AddDatabase(::google::protobuf::RpcController* controller,
                       const ::hybridse::dbms::AddDatabaseRequest* request,
                       ::hybridse::dbms::AddDatabaseResponse* response,
                       ::google::protobuf::Closure* done);
  void AddTable(::google::protobuf::RpcController* controller,
                       const ::hybridse::dbms::AddTableRequest* request,
                       ::hybridse::dbms::AddTableResponse* response,
                       ::google::protobuf::Closure* done);
  void GetSchema(::google::protobuf::RpcController* controller,
                       const ::hybridse::dbms::GetSchemaRequest* request,
                       ::hybridse::dbms::GetSchemaResponse* response,
                       ::google::protobuf::Closure* done);
  void GetDatabases(::google::protobuf::RpcController* controller,
                       const ::hybridse::dbms::GetDatabasesRequest* request,
                       ::hybridse::dbms::GetDatabasesResponse* response,
                       ::google::protobuf::Closure* done);
  void GetTables(::google::protobuf::RpcController* controller,
                       const ::hybridse::dbms::GetTablesRequest* request,
                       ::hybridse::dbms::GetTablesResponse* response,
                       ::google::protobuf::Closure* done);
  void KeepAlive(::google::protobuf::RpcController* controller,
                       const ::hybridse::dbms::KeepAliveRequest* request,
                       ::hybridse::dbms::KeepAliveResponse* response,
                       ::google::protobuf::Closure* done);
  void GetTablet(::google::protobuf::RpcController* controller,
                       const ::hybridse::dbms::GetTabletRequest* request,
                       ::hybridse::dbms::GetTabletResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(DBMSServer_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AddGroupRequest

// optional string name = 1;
inline bool AddGroupRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddGroupRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddGroupRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddGroupRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& AddGroupRequest::name() const {
  // @@protoc_insertion_point(field_get:hybridse.dbms.AddGroupRequest.name)
  return name_.GetNoArena();
}
inline void AddGroupRequest::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.dbms.AddGroupRequest.name)
}
#if LANG_CXX11
inline void AddGroupRequest::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.dbms.AddGroupRequest.name)
}
#endif
inline void AddGroupRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.dbms.AddGroupRequest.name)
}
inline void AddGroupRequest::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.dbms.AddGroupRequest.name)
}
inline ::std::string* AddGroupRequest::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.AddGroupRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddGroupRequest::release_name() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.AddGroupRequest.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddGroupRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.AddGroupRequest.name)
}

// -------------------------------------------------------------------

// AddGroupResponse

// optional .hybridse.common.Status status = 1;
inline bool AddGroupResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddGroupResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddGroupResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hybridse::common::Status& AddGroupResponse::_internal_status() const {
  return *status_;
}
inline const ::hybridse::common::Status& AddGroupResponse::status() const {
  const ::hybridse::common::Status* p = status_;
  // @@protoc_insertion_point(field_get:hybridse.dbms.AddGroupResponse.status)
  return p != NULL ? *p : *reinterpret_cast<const ::hybridse::common::Status*>(
      &::hybridse::common::_Status_default_instance_);
}
inline ::hybridse::common::Status* AddGroupResponse::release_status() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.AddGroupResponse.status)
  clear_has_status();
  ::hybridse::common::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::hybridse::common::Status* AddGroupResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::hybridse::common::Status>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.AddGroupResponse.status)
  return status_;
}
inline void AddGroupResponse::set_allocated_status(::hybridse::common::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.AddGroupResponse.status)
}

// -------------------------------------------------------------------

// AddDatabaseRequest

// optional string name = 1;
inline bool AddDatabaseRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddDatabaseRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddDatabaseRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddDatabaseRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& AddDatabaseRequest::name() const {
  // @@protoc_insertion_point(field_get:hybridse.dbms.AddDatabaseRequest.name)
  return name_.GetNoArena();
}
inline void AddDatabaseRequest::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.dbms.AddDatabaseRequest.name)
}
#if LANG_CXX11
inline void AddDatabaseRequest::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.dbms.AddDatabaseRequest.name)
}
#endif
inline void AddDatabaseRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.dbms.AddDatabaseRequest.name)
}
inline void AddDatabaseRequest::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.dbms.AddDatabaseRequest.name)
}
inline ::std::string* AddDatabaseRequest::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.AddDatabaseRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddDatabaseRequest::release_name() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.AddDatabaseRequest.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddDatabaseRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.AddDatabaseRequest.name)
}

// -------------------------------------------------------------------

// AddDatabaseResponse

// optional .hybridse.common.Status status = 1;
inline bool AddDatabaseResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddDatabaseResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddDatabaseResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hybridse::common::Status& AddDatabaseResponse::_internal_status() const {
  return *status_;
}
inline const ::hybridse::common::Status& AddDatabaseResponse::status() const {
  const ::hybridse::common::Status* p = status_;
  // @@protoc_insertion_point(field_get:hybridse.dbms.AddDatabaseResponse.status)
  return p != NULL ? *p : *reinterpret_cast<const ::hybridse::common::Status*>(
      &::hybridse::common::_Status_default_instance_);
}
inline ::hybridse::common::Status* AddDatabaseResponse::release_status() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.AddDatabaseResponse.status)
  clear_has_status();
  ::hybridse::common::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::hybridse::common::Status* AddDatabaseResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::hybridse::common::Status>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.AddDatabaseResponse.status)
  return status_;
}
inline void AddDatabaseResponse::set_allocated_status(::hybridse::common::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.AddDatabaseResponse.status)
}

// -------------------------------------------------------------------

// IsExistRequest

// optional string name = 1;
inline bool IsExistRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsExistRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsExistRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IsExistRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& IsExistRequest::name() const {
  // @@protoc_insertion_point(field_get:hybridse.dbms.IsExistRequest.name)
  return name_.GetNoArena();
}
inline void IsExistRequest::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.dbms.IsExistRequest.name)
}
#if LANG_CXX11
inline void IsExistRequest::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.dbms.IsExistRequest.name)
}
#endif
inline void IsExistRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.dbms.IsExistRequest.name)
}
inline void IsExistRequest::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.dbms.IsExistRequest.name)
}
inline ::std::string* IsExistRequest::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.IsExistRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IsExistRequest::release_name() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.IsExistRequest.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IsExistRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.IsExistRequest.name)
}

// -------------------------------------------------------------------

// IsExistResponse

// optional .hybridse.common.Status status = 1;
inline bool IsExistResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IsExistResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IsExistResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hybridse::common::Status& IsExistResponse::_internal_status() const {
  return *status_;
}
inline const ::hybridse::common::Status& IsExistResponse::status() const {
  const ::hybridse::common::Status* p = status_;
  // @@protoc_insertion_point(field_get:hybridse.dbms.IsExistResponse.status)
  return p != NULL ? *p : *reinterpret_cast<const ::hybridse::common::Status*>(
      &::hybridse::common::_Status_default_instance_);
}
inline ::hybridse::common::Status* IsExistResponse::release_status() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.IsExistResponse.status)
  clear_has_status();
  ::hybridse::common::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::hybridse::common::Status* IsExistResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::hybridse::common::Status>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.IsExistResponse.status)
  return status_;
}
inline void IsExistResponse::set_allocated_status(::hybridse::common::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.IsExistResponse.status)
}

// optional bool exist = 2;
inline bool IsExistResponse::has_exist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IsExistResponse::set_has_exist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IsExistResponse::clear_has_exist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IsExistResponse::clear_exist() {
  exist_ = false;
  clear_has_exist();
}
inline bool IsExistResponse::exist() const {
  // @@protoc_insertion_point(field_get:hybridse.dbms.IsExistResponse.exist)
  return exist_;
}
inline void IsExistResponse::set_exist(bool value) {
  set_has_exist();
  exist_ = value;
  // @@protoc_insertion_point(field_set:hybridse.dbms.IsExistResponse.exist)
}

// -------------------------------------------------------------------

// AddTableRequest

// optional .hybridse.type.TableDef table = 1;
inline bool AddTableRequest::has_table() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddTableRequest::set_has_table() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddTableRequest::clear_has_table() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hybridse::type::TableDef& AddTableRequest::_internal_table() const {
  return *table_;
}
inline const ::hybridse::type::TableDef& AddTableRequest::table() const {
  const ::hybridse::type::TableDef* p = table_;
  // @@protoc_insertion_point(field_get:hybridse.dbms.AddTableRequest.table)
  return p != NULL ? *p : *reinterpret_cast<const ::hybridse::type::TableDef*>(
      &::hybridse::type::_TableDef_default_instance_);
}
inline ::hybridse::type::TableDef* AddTableRequest::release_table() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.AddTableRequest.table)
  clear_has_table();
  ::hybridse::type::TableDef* temp = table_;
  table_ = NULL;
  return temp;
}
inline ::hybridse::type::TableDef* AddTableRequest::mutable_table() {
  set_has_table();
  if (table_ == NULL) {
    auto* p = CreateMaybeMessage<::hybridse::type::TableDef>(GetArenaNoVirtual());
    table_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.AddTableRequest.table)
  return table_;
}
inline void AddTableRequest::set_allocated_table(::hybridse::type::TableDef* table) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(table_);
  }
  if (table) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      table = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    set_has_table();
  } else {
    clear_has_table();
  }
  table_ = table;
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.AddTableRequest.table)
}

// optional string db_name = 2;
inline bool AddTableRequest::has_db_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddTableRequest::set_has_db_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddTableRequest::clear_has_db_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddTableRequest::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_db_name();
}
inline const ::std::string& AddTableRequest::db_name() const {
  // @@protoc_insertion_point(field_get:hybridse.dbms.AddTableRequest.db_name)
  return db_name_.GetNoArena();
}
inline void AddTableRequest::set_db_name(const ::std::string& value) {
  set_has_db_name();
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.dbms.AddTableRequest.db_name)
}
#if LANG_CXX11
inline void AddTableRequest::set_db_name(::std::string&& value) {
  set_has_db_name();
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.dbms.AddTableRequest.db_name)
}
#endif
inline void AddTableRequest::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_db_name();
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.dbms.AddTableRequest.db_name)
}
inline void AddTableRequest::set_db_name(const char* value, size_t size) {
  set_has_db_name();
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.dbms.AddTableRequest.db_name)
}
inline ::std::string* AddTableRequest::mutable_db_name() {
  set_has_db_name();
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.AddTableRequest.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddTableRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.AddTableRequest.db_name)
  if (!has_db_name()) {
    return NULL;
  }
  clear_has_db_name();
  return db_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddTableRequest::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    set_has_db_name();
  } else {
    clear_has_db_name();
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.AddTableRequest.db_name)
}

// -------------------------------------------------------------------

// AddTableResponse

// optional .hybridse.common.Status status = 1;
inline bool AddTableResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddTableResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddTableResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hybridse::common::Status& AddTableResponse::_internal_status() const {
  return *status_;
}
inline const ::hybridse::common::Status& AddTableResponse::status() const {
  const ::hybridse::common::Status* p = status_;
  // @@protoc_insertion_point(field_get:hybridse.dbms.AddTableResponse.status)
  return p != NULL ? *p : *reinterpret_cast<const ::hybridse::common::Status*>(
      &::hybridse::common::_Status_default_instance_);
}
inline ::hybridse::common::Status* AddTableResponse::release_status() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.AddTableResponse.status)
  clear_has_status();
  ::hybridse::common::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::hybridse::common::Status* AddTableResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::hybridse::common::Status>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.AddTableResponse.status)
  return status_;
}
inline void AddTableResponse::set_allocated_status(::hybridse::common::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.AddTableResponse.status)
}

// -------------------------------------------------------------------

// GetSchemaRequest

// optional string name = 1;
inline bool GetSchemaRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSchemaRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSchemaRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSchemaRequest::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& GetSchemaRequest::name() const {
  // @@protoc_insertion_point(field_get:hybridse.dbms.GetSchemaRequest.name)
  return name_.GetNoArena();
}
inline void GetSchemaRequest::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.dbms.GetSchemaRequest.name)
}
#if LANG_CXX11
inline void GetSchemaRequest::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.dbms.GetSchemaRequest.name)
}
#endif
inline void GetSchemaRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.dbms.GetSchemaRequest.name)
}
inline void GetSchemaRequest::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.dbms.GetSchemaRequest.name)
}
inline ::std::string* GetSchemaRequest::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.GetSchemaRequest.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSchemaRequest::release_name() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.GetSchemaRequest.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSchemaRequest::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.GetSchemaRequest.name)
}

// optional string db_name = 2;
inline bool GetSchemaRequest::has_db_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSchemaRequest::set_has_db_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSchemaRequest::clear_has_db_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSchemaRequest::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_db_name();
}
inline const ::std::string& GetSchemaRequest::db_name() const {
  // @@protoc_insertion_point(field_get:hybridse.dbms.GetSchemaRequest.db_name)
  return db_name_.GetNoArena();
}
inline void GetSchemaRequest::set_db_name(const ::std::string& value) {
  set_has_db_name();
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.dbms.GetSchemaRequest.db_name)
}
#if LANG_CXX11
inline void GetSchemaRequest::set_db_name(::std::string&& value) {
  set_has_db_name();
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.dbms.GetSchemaRequest.db_name)
}
#endif
inline void GetSchemaRequest::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_db_name();
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.dbms.GetSchemaRequest.db_name)
}
inline void GetSchemaRequest::set_db_name(const char* value, size_t size) {
  set_has_db_name();
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.dbms.GetSchemaRequest.db_name)
}
inline ::std::string* GetSchemaRequest::mutable_db_name() {
  set_has_db_name();
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.GetSchemaRequest.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSchemaRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.GetSchemaRequest.db_name)
  if (!has_db_name()) {
    return NULL;
  }
  clear_has_db_name();
  return db_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSchemaRequest::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    set_has_db_name();
  } else {
    clear_has_db_name();
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.GetSchemaRequest.db_name)
}

// -------------------------------------------------------------------

// GetSchemaResponse

// optional .hybridse.common.Status status = 1;
inline bool GetSchemaResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSchemaResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSchemaResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hybridse::common::Status& GetSchemaResponse::_internal_status() const {
  return *status_;
}
inline const ::hybridse::common::Status& GetSchemaResponse::status() const {
  const ::hybridse::common::Status* p = status_;
  // @@protoc_insertion_point(field_get:hybridse.dbms.GetSchemaResponse.status)
  return p != NULL ? *p : *reinterpret_cast<const ::hybridse::common::Status*>(
      &::hybridse::common::_Status_default_instance_);
}
inline ::hybridse::common::Status* GetSchemaResponse::release_status() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.GetSchemaResponse.status)
  clear_has_status();
  ::hybridse::common::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::hybridse::common::Status* GetSchemaResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::hybridse::common::Status>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.GetSchemaResponse.status)
  return status_;
}
inline void GetSchemaResponse::set_allocated_status(::hybridse::common::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.GetSchemaResponse.status)
}

// optional .hybridse.type.TableDef table = 2;
inline bool GetSchemaResponse::has_table() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSchemaResponse::set_has_table() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSchemaResponse::clear_has_table() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::hybridse::type::TableDef& GetSchemaResponse::_internal_table() const {
  return *table_;
}
inline const ::hybridse::type::TableDef& GetSchemaResponse::table() const {
  const ::hybridse::type::TableDef* p = table_;
  // @@protoc_insertion_point(field_get:hybridse.dbms.GetSchemaResponse.table)
  return p != NULL ? *p : *reinterpret_cast<const ::hybridse::type::TableDef*>(
      &::hybridse::type::_TableDef_default_instance_);
}
inline ::hybridse::type::TableDef* GetSchemaResponse::release_table() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.GetSchemaResponse.table)
  clear_has_table();
  ::hybridse::type::TableDef* temp = table_;
  table_ = NULL;
  return temp;
}
inline ::hybridse::type::TableDef* GetSchemaResponse::mutable_table() {
  set_has_table();
  if (table_ == NULL) {
    auto* p = CreateMaybeMessage<::hybridse::type::TableDef>(GetArenaNoVirtual());
    table_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.GetSchemaResponse.table)
  return table_;
}
inline void GetSchemaResponse::set_allocated_table(::hybridse::type::TableDef* table) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(table_);
  }
  if (table) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      table = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    set_has_table();
  } else {
    clear_has_table();
  }
  table_ = table;
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.GetSchemaResponse.table)
}

// -------------------------------------------------------------------

// GetDatabasesRequest

// -------------------------------------------------------------------

// GetDatabasesResponse

// optional .hybridse.common.Status status = 1;
inline bool GetDatabasesResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetDatabasesResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetDatabasesResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hybridse::common::Status& GetDatabasesResponse::_internal_status() const {
  return *status_;
}
inline const ::hybridse::common::Status& GetDatabasesResponse::status() const {
  const ::hybridse::common::Status* p = status_;
  // @@protoc_insertion_point(field_get:hybridse.dbms.GetDatabasesResponse.status)
  return p != NULL ? *p : *reinterpret_cast<const ::hybridse::common::Status*>(
      &::hybridse::common::_Status_default_instance_);
}
inline ::hybridse::common::Status* GetDatabasesResponse::release_status() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.GetDatabasesResponse.status)
  clear_has_status();
  ::hybridse::common::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::hybridse::common::Status* GetDatabasesResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::hybridse::common::Status>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.GetDatabasesResponse.status)
  return status_;
}
inline void GetDatabasesResponse::set_allocated_status(::hybridse::common::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.GetDatabasesResponse.status)
}

// repeated string names = 2;
inline int GetDatabasesResponse::names_size() const {
  return names_.size();
}
inline void GetDatabasesResponse::clear_names() {
  names_.Clear();
}
inline const ::std::string& GetDatabasesResponse::names(int index) const {
  // @@protoc_insertion_point(field_get:hybridse.dbms.GetDatabasesResponse.names)
  return names_.Get(index);
}
inline ::std::string* GetDatabasesResponse::mutable_names(int index) {
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.GetDatabasesResponse.names)
  return names_.Mutable(index);
}
inline void GetDatabasesResponse::set_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hybridse.dbms.GetDatabasesResponse.names)
  names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetDatabasesResponse::set_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hybridse.dbms.GetDatabasesResponse.names)
  names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetDatabasesResponse::set_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hybridse.dbms.GetDatabasesResponse.names)
}
inline void GetDatabasesResponse::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hybridse.dbms.GetDatabasesResponse.names)
}
inline ::std::string* GetDatabasesResponse::add_names() {
  // @@protoc_insertion_point(field_add_mutable:hybridse.dbms.GetDatabasesResponse.names)
  return names_.Add();
}
inline void GetDatabasesResponse::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hybridse.dbms.GetDatabasesResponse.names)
}
#if LANG_CXX11
inline void GetDatabasesResponse::add_names(::std::string&& value) {
  names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hybridse.dbms.GetDatabasesResponse.names)
}
#endif
inline void GetDatabasesResponse::add_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hybridse.dbms.GetDatabasesResponse.names)
}
inline void GetDatabasesResponse::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hybridse.dbms.GetDatabasesResponse.names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetDatabasesResponse::names() const {
  // @@protoc_insertion_point(field_list:hybridse.dbms.GetDatabasesResponse.names)
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetDatabasesResponse::mutable_names() {
  // @@protoc_insertion_point(field_mutable_list:hybridse.dbms.GetDatabasesResponse.names)
  return &names_;
}

// -------------------------------------------------------------------

// GetTablesRequest

// optional string db_name = 1;
inline bool GetTablesRequest::has_db_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTablesRequest::set_has_db_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTablesRequest::clear_has_db_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetTablesRequest::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_db_name();
}
inline const ::std::string& GetTablesRequest::db_name() const {
  // @@protoc_insertion_point(field_get:hybridse.dbms.GetTablesRequest.db_name)
  return db_name_.GetNoArena();
}
inline void GetTablesRequest::set_db_name(const ::std::string& value) {
  set_has_db_name();
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.dbms.GetTablesRequest.db_name)
}
#if LANG_CXX11
inline void GetTablesRequest::set_db_name(::std::string&& value) {
  set_has_db_name();
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.dbms.GetTablesRequest.db_name)
}
#endif
inline void GetTablesRequest::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_db_name();
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.dbms.GetTablesRequest.db_name)
}
inline void GetTablesRequest::set_db_name(const char* value, size_t size) {
  set_has_db_name();
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.dbms.GetTablesRequest.db_name)
}
inline ::std::string* GetTablesRequest::mutable_db_name() {
  set_has_db_name();
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.GetTablesRequest.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetTablesRequest::release_db_name() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.GetTablesRequest.db_name)
  if (!has_db_name()) {
    return NULL;
  }
  clear_has_db_name();
  return db_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTablesRequest::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    set_has_db_name();
  } else {
    clear_has_db_name();
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.GetTablesRequest.db_name)
}

// optional string table_name = 2;
inline bool GetTablesRequest::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetTablesRequest::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetTablesRequest::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetTablesRequest::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_table_name();
}
inline const ::std::string& GetTablesRequest::table_name() const {
  // @@protoc_insertion_point(field_get:hybridse.dbms.GetTablesRequest.table_name)
  return table_name_.GetNoArena();
}
inline void GetTablesRequest::set_table_name(const ::std::string& value) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.dbms.GetTablesRequest.table_name)
}
#if LANG_CXX11
inline void GetTablesRequest::set_table_name(::std::string&& value) {
  set_has_table_name();
  table_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.dbms.GetTablesRequest.table_name)
}
#endif
inline void GetTablesRequest::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.dbms.GetTablesRequest.table_name)
}
inline void GetTablesRequest::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.dbms.GetTablesRequest.table_name)
}
inline ::std::string* GetTablesRequest::mutable_table_name() {
  set_has_table_name();
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.GetTablesRequest.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetTablesRequest::release_table_name() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.GetTablesRequest.table_name)
  if (!has_table_name()) {
    return NULL;
  }
  clear_has_table_name();
  return table_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetTablesRequest::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.GetTablesRequest.table_name)
}

// -------------------------------------------------------------------

// GetTablesResponse

// optional .hybridse.common.Status status = 1;
inline bool GetTablesResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTablesResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTablesResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hybridse::common::Status& GetTablesResponse::_internal_status() const {
  return *status_;
}
inline const ::hybridse::common::Status& GetTablesResponse::status() const {
  const ::hybridse::common::Status* p = status_;
  // @@protoc_insertion_point(field_get:hybridse.dbms.GetTablesResponse.status)
  return p != NULL ? *p : *reinterpret_cast<const ::hybridse::common::Status*>(
      &::hybridse::common::_Status_default_instance_);
}
inline ::hybridse::common::Status* GetTablesResponse::release_status() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.GetTablesResponse.status)
  clear_has_status();
  ::hybridse::common::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::hybridse::common::Status* GetTablesResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::hybridse::common::Status>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.GetTablesResponse.status)
  return status_;
}
inline void GetTablesResponse::set_allocated_status(::hybridse::common::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.GetTablesResponse.status)
}

// repeated .hybridse.type.TableDef tables = 2;
inline int GetTablesResponse::tables_size() const {
  return tables_.size();
}
inline ::hybridse::type::TableDef* GetTablesResponse::mutable_tables(int index) {
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.GetTablesResponse.tables)
  return tables_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hybridse::type::TableDef >*
GetTablesResponse::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_list:hybridse.dbms.GetTablesResponse.tables)
  return &tables_;
}
inline const ::hybridse::type::TableDef& GetTablesResponse::tables(int index) const {
  // @@protoc_insertion_point(field_get:hybridse.dbms.GetTablesResponse.tables)
  return tables_.Get(index);
}
inline ::hybridse::type::TableDef* GetTablesResponse::add_tables() {
  // @@protoc_insertion_point(field_add:hybridse.dbms.GetTablesResponse.tables)
  return tables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hybridse::type::TableDef >&
GetTablesResponse::tables() const {
  // @@protoc_insertion_point(field_list:hybridse.dbms.GetTablesResponse.tables)
  return tables_;
}

// -------------------------------------------------------------------

// KeepAliveRequest

// optional string endpoint = 1;
inline bool KeepAliveRequest::has_endpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeepAliveRequest::set_has_endpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeepAliveRequest::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeepAliveRequest::clear_endpoint() {
  endpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_endpoint();
}
inline const ::std::string& KeepAliveRequest::endpoint() const {
  // @@protoc_insertion_point(field_get:hybridse.dbms.KeepAliveRequest.endpoint)
  return endpoint_.GetNoArena();
}
inline void KeepAliveRequest::set_endpoint(const ::std::string& value) {
  set_has_endpoint();
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.dbms.KeepAliveRequest.endpoint)
}
#if LANG_CXX11
inline void KeepAliveRequest::set_endpoint(::std::string&& value) {
  set_has_endpoint();
  endpoint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.dbms.KeepAliveRequest.endpoint)
}
#endif
inline void KeepAliveRequest::set_endpoint(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_endpoint();
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.dbms.KeepAliveRequest.endpoint)
}
inline void KeepAliveRequest::set_endpoint(const char* value, size_t size) {
  set_has_endpoint();
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.dbms.KeepAliveRequest.endpoint)
}
inline ::std::string* KeepAliveRequest::mutable_endpoint() {
  set_has_endpoint();
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.KeepAliveRequest.endpoint)
  return endpoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeepAliveRequest::release_endpoint() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.KeepAliveRequest.endpoint)
  if (!has_endpoint()) {
    return NULL;
  }
  clear_has_endpoint();
  return endpoint_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeepAliveRequest::set_allocated_endpoint(::std::string* endpoint) {
  if (endpoint != NULL) {
    set_has_endpoint();
  } else {
    clear_has_endpoint();
  }
  endpoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), endpoint);
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.KeepAliveRequest.endpoint)
}

// -------------------------------------------------------------------

// KeepAliveResponse

// optional .hybridse.common.Status status = 1;
inline bool KeepAliveResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeepAliveResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeepAliveResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hybridse::common::Status& KeepAliveResponse::_internal_status() const {
  return *status_;
}
inline const ::hybridse::common::Status& KeepAliveResponse::status() const {
  const ::hybridse::common::Status* p = status_;
  // @@protoc_insertion_point(field_get:hybridse.dbms.KeepAliveResponse.status)
  return p != NULL ? *p : *reinterpret_cast<const ::hybridse::common::Status*>(
      &::hybridse::common::_Status_default_instance_);
}
inline ::hybridse::common::Status* KeepAliveResponse::release_status() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.KeepAliveResponse.status)
  clear_has_status();
  ::hybridse::common::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::hybridse::common::Status* KeepAliveResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::hybridse::common::Status>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.KeepAliveResponse.status)
  return status_;
}
inline void KeepAliveResponse::set_allocated_status(::hybridse::common::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.KeepAliveResponse.status)
}

// -------------------------------------------------------------------

// GetTabletRequest

// -------------------------------------------------------------------

// GetTabletResponse

// optional .hybridse.common.Status status = 1;
inline bool GetTabletResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetTabletResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetTabletResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::hybridse::common::Status& GetTabletResponse::_internal_status() const {
  return *status_;
}
inline const ::hybridse::common::Status& GetTabletResponse::status() const {
  const ::hybridse::common::Status* p = status_;
  // @@protoc_insertion_point(field_get:hybridse.dbms.GetTabletResponse.status)
  return p != NULL ? *p : *reinterpret_cast<const ::hybridse::common::Status*>(
      &::hybridse::common::_Status_default_instance_);
}
inline ::hybridse::common::Status* GetTabletResponse::release_status() {
  // @@protoc_insertion_point(field_release:hybridse.dbms.GetTabletResponse.status)
  clear_has_status();
  ::hybridse::common::Status* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::hybridse::common::Status* GetTabletResponse::mutable_status() {
  set_has_status();
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::hybridse::common::Status>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.GetTabletResponse.status)
  return status_;
}
inline void GetTabletResponse::set_allocated_status(::hybridse::common::Status* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(status_);
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    set_has_status();
  } else {
    clear_has_status();
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:hybridse.dbms.GetTabletResponse.status)
}

// repeated string endpoints = 2;
inline int GetTabletResponse::endpoints_size() const {
  return endpoints_.size();
}
inline void GetTabletResponse::clear_endpoints() {
  endpoints_.Clear();
}
inline const ::std::string& GetTabletResponse::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:hybridse.dbms.GetTabletResponse.endpoints)
  return endpoints_.Get(index);
}
inline ::std::string* GetTabletResponse::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:hybridse.dbms.GetTabletResponse.endpoints)
  return endpoints_.Mutable(index);
}
inline void GetTabletResponse::set_endpoints(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hybridse.dbms.GetTabletResponse.endpoints)
  endpoints_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetTabletResponse::set_endpoints(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hybridse.dbms.GetTabletResponse.endpoints)
  endpoints_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetTabletResponse::set_endpoints(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  endpoints_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hybridse.dbms.GetTabletResponse.endpoints)
}
inline void GetTabletResponse::set_endpoints(int index, const char* value, size_t size) {
  endpoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hybridse.dbms.GetTabletResponse.endpoints)
}
inline ::std::string* GetTabletResponse::add_endpoints() {
  // @@protoc_insertion_point(field_add_mutable:hybridse.dbms.GetTabletResponse.endpoints)
  return endpoints_.Add();
}
inline void GetTabletResponse::add_endpoints(const ::std::string& value) {
  endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hybridse.dbms.GetTabletResponse.endpoints)
}
#if LANG_CXX11
inline void GetTabletResponse::add_endpoints(::std::string&& value) {
  endpoints_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hybridse.dbms.GetTabletResponse.endpoints)
}
#endif
inline void GetTabletResponse::add_endpoints(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  endpoints_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hybridse.dbms.GetTabletResponse.endpoints)
}
inline void GetTabletResponse::add_endpoints(const char* value, size_t size) {
  endpoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hybridse.dbms.GetTabletResponse.endpoints)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetTabletResponse::endpoints() const {
  // @@protoc_insertion_point(field_list:hybridse.dbms.GetTabletResponse.endpoints)
  return endpoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetTabletResponse::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:hybridse.dbms.GetTabletResponse.endpoints)
  return &endpoints_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dbms
}  // namespace hybridse

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_dbms_2eproto
