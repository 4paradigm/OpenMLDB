// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: common.proto

#ifndef PROTOBUF_INCLUDED_common_2eproto
#define PROTOBUF_INCLUDED_common_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "type.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_common_2eproto 

namespace protobuf_common_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[12];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_common_2eproto
namespace openmldb {
namespace common {
class CatalogInfo;
class CatalogInfoDefaultTypeInternal;
extern CatalogInfoDefaultTypeInternal _CatalogInfo_default_instance_;
class ColumnDesc;
class ColumnDescDefaultTypeInternal;
extern ColumnDescDefaultTypeInternal _ColumnDesc_default_instance_;
class ColumnKey;
class ColumnKeyDefaultTypeInternal;
extern ColumnKeyDefaultTypeInternal _ColumnKey_default_instance_;
class DbTableNamePair;
class DbTableNamePairDefaultTypeInternal;
extern DbTableNamePairDefaultTypeInternal _DbTableNamePair_default_instance_;
class EndpointAndTid;
class EndpointAndTidDefaultTypeInternal;
extern EndpointAndTidDefaultTypeInternal _EndpointAndTid_default_instance_;
class ExternalFun;
class ExternalFunDefaultTypeInternal;
extern ExternalFunDefaultTypeInternal _ExternalFun_default_instance_;
class KvList;
class KvListDefaultTypeInternal;
extern KvListDefaultTypeInternal _KvList_default_instance_;
class KvPair;
class KvPairDefaultTypeInternal;
extern KvPairDefaultTypeInternal _KvPair_default_instance_;
class PartitionMeta;
class PartitionMetaDefaultTypeInternal;
extern PartitionMetaDefaultTypeInternal _PartitionMeta_default_instance_;
class TTLSt;
class TTLStDefaultTypeInternal;
extern TTLStDefaultTypeInternal _TTLSt_default_instance_;
class TablePartition;
class TablePartitionDefaultTypeInternal;
extern TablePartitionDefaultTypeInternal _TablePartition_default_instance_;
class VersionPair;
class VersionPairDefaultTypeInternal;
extern VersionPairDefaultTypeInternal _VersionPair_default_instance_;
}  // namespace common
}  // namespace openmldb
namespace google {
namespace protobuf {
template<> ::openmldb::common::CatalogInfo* Arena::CreateMaybeMessage<::openmldb::common::CatalogInfo>(Arena*);
template<> ::openmldb::common::ColumnDesc* Arena::CreateMaybeMessage<::openmldb::common::ColumnDesc>(Arena*);
template<> ::openmldb::common::ColumnKey* Arena::CreateMaybeMessage<::openmldb::common::ColumnKey>(Arena*);
template<> ::openmldb::common::DbTableNamePair* Arena::CreateMaybeMessage<::openmldb::common::DbTableNamePair>(Arena*);
template<> ::openmldb::common::EndpointAndTid* Arena::CreateMaybeMessage<::openmldb::common::EndpointAndTid>(Arena*);
template<> ::openmldb::common::ExternalFun* Arena::CreateMaybeMessage<::openmldb::common::ExternalFun>(Arena*);
template<> ::openmldb::common::KvList* Arena::CreateMaybeMessage<::openmldb::common::KvList>(Arena*);
template<> ::openmldb::common::KvPair* Arena::CreateMaybeMessage<::openmldb::common::KvPair>(Arena*);
template<> ::openmldb::common::PartitionMeta* Arena::CreateMaybeMessage<::openmldb::common::PartitionMeta>(Arena*);
template<> ::openmldb::common::TTLSt* Arena::CreateMaybeMessage<::openmldb::common::TTLSt>(Arena*);
template<> ::openmldb::common::TablePartition* Arena::CreateMaybeMessage<::openmldb::common::TablePartition>(Arena*);
template<> ::openmldb::common::VersionPair* Arena::CreateMaybeMessage<::openmldb::common::VersionPair>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace openmldb {
namespace common {

enum StorageMode {
  kUnknown = 0,
  kMemory = 1,
  kSSD = 2,
  kHDD = 3
};
bool StorageMode_IsValid(int value);
const StorageMode StorageMode_MIN = kUnknown;
const StorageMode StorageMode_MAX = kHDD;
const int StorageMode_ARRAYSIZE = StorageMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* StorageMode_descriptor();
inline const ::std::string& StorageMode_Name(StorageMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    StorageMode_descriptor(), value);
}
inline bool StorageMode_Parse(
    const ::std::string& name, StorageMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StorageMode>(
    StorageMode_descriptor(), name, value);
}
// ===================================================================

class KvPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:openmldb.common.KvPair) */ {
 public:
  KvPair();
  virtual ~KvPair();

  KvPair(const KvPair& from);

  inline KvPair& operator=(const KvPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvPair(KvPair&& from) noexcept
    : KvPair() {
    *this = ::std::move(from);
  }

  inline KvPair& operator=(KvPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KvPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KvPair* internal_default_instance() {
    return reinterpret_cast<const KvPair*>(
               &_KvPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(KvPair* other);
  friend void swap(KvPair& a, KvPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvPair* New() const final {
    return CreateMaybeMessage<KvPair>(NULL);
  }

  KvPair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KvPair>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KvPair& from);
  void MergeFrom(const KvPair& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KvPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional int64 time = 1;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:openmldb.common.KvPair)
 private:
  void set_has_time();
  void clear_has_time();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::int64 time_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KvList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:openmldb.common.KvList) */ {
 public:
  KvList();
  virtual ~KvList();

  KvList(const KvList& from);

  inline KvList& operator=(const KvList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KvList(KvList&& from) noexcept
    : KvList() {
    *this = ::std::move(from);
  }

  inline KvList& operator=(KvList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KvList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KvList* internal_default_instance() {
    return reinterpret_cast<const KvList*>(
               &_KvList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(KvList* other);
  friend void swap(KvList& a, KvList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KvList* New() const final {
    return CreateMaybeMessage<KvList>(NULL);
  }

  KvList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KvList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KvList& from);
  void MergeFrom(const KvList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KvList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .openmldb.common.KvPair pairs = 2;
  int pairs_size() const;
  void clear_pairs();
  static const int kPairsFieldNumber = 2;
  ::openmldb::common::KvPair* mutable_pairs(int index);
  ::google::protobuf::RepeatedPtrField< ::openmldb::common::KvPair >*
      mutable_pairs();
  const ::openmldb::common::KvPair& pairs(int index) const;
  ::openmldb::common::KvPair* add_pairs();
  const ::google::protobuf::RepeatedPtrField< ::openmldb::common::KvPair >&
      pairs() const;

  // optional string pk = 1;
  bool has_pk() const;
  void clear_pk();
  static const int kPkFieldNumber = 1;
  const ::std::string& pk() const;
  void set_pk(const ::std::string& value);
  #if LANG_CXX11
  void set_pk(::std::string&& value);
  #endif
  void set_pk(const char* value);
  void set_pk(const char* value, size_t size);
  ::std::string* mutable_pk();
  ::std::string* release_pk();
  void set_allocated_pk(::std::string* pk);

  // @@protoc_insertion_point(class_scope:openmldb.common.KvList)
 private:
  void set_has_pk();
  void clear_has_pk();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::openmldb::common::KvPair > pairs_;
  ::google::protobuf::internal::ArenaStringPtr pk_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VersionPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:openmldb.common.VersionPair) */ {
 public:
  VersionPair();
  virtual ~VersionPair();

  VersionPair(const VersionPair& from);

  inline VersionPair& operator=(const VersionPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VersionPair(VersionPair&& from) noexcept
    : VersionPair() {
    *this = ::std::move(from);
  }

  inline VersionPair& operator=(VersionPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VersionPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VersionPair* internal_default_instance() {
    return reinterpret_cast<const VersionPair*>(
               &_VersionPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(VersionPair* other);
  friend void swap(VersionPair& a, VersionPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VersionPair* New() const final {
    return CreateMaybeMessage<VersionPair>(NULL);
  }

  VersionPair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VersionPair>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VersionPair& from);
  void MergeFrom(const VersionPair& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VersionPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional int32 field_count = 2;
  bool has_field_count() const;
  void clear_field_count();
  static const int kFieldCountFieldNumber = 2;
  ::google::protobuf::int32 field_count() const;
  void set_field_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:openmldb.common.VersionPair)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_field_count();
  void clear_has_field_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 field_count_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DbTableNamePair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:openmldb.common.DbTableNamePair) */ {
 public:
  DbTableNamePair();
  virtual ~DbTableNamePair();

  DbTableNamePair(const DbTableNamePair& from);

  inline DbTableNamePair& operator=(const DbTableNamePair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DbTableNamePair(DbTableNamePair&& from) noexcept
    : DbTableNamePair() {
    *this = ::std::move(from);
  }

  inline DbTableNamePair& operator=(DbTableNamePair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DbTableNamePair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DbTableNamePair* internal_default_instance() {
    return reinterpret_cast<const DbTableNamePair*>(
               &_DbTableNamePair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(DbTableNamePair* other);
  friend void swap(DbTableNamePair& a, DbTableNamePair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DbTableNamePair* New() const final {
    return CreateMaybeMessage<DbTableNamePair>(NULL);
  }

  DbTableNamePair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DbTableNamePair>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DbTableNamePair& from);
  void MergeFrom(const DbTableNamePair& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DbTableNamePair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string db_name = 1;
  bool has_db_name() const;
  void clear_db_name();
  static const int kDbNameFieldNumber = 1;
  const ::std::string& db_name() const;
  void set_db_name(const ::std::string& value);
  #if LANG_CXX11
  void set_db_name(::std::string&& value);
  #endif
  void set_db_name(const char* value);
  void set_db_name(const char* value, size_t size);
  ::std::string* mutable_db_name();
  ::std::string* release_db_name();
  void set_allocated_db_name(::std::string* db_name);

  // required string table_name = 2;
  bool has_table_name() const;
  void clear_table_name();
  static const int kTableNameFieldNumber = 2;
  const ::std::string& table_name() const;
  void set_table_name(const ::std::string& value);
  #if LANG_CXX11
  void set_table_name(::std::string&& value);
  #endif
  void set_table_name(const char* value);
  void set_table_name(const char* value, size_t size);
  ::std::string* mutable_table_name();
  ::std::string* release_table_name();
  void set_allocated_table_name(::std::string* table_name);

  // @@protoc_insertion_point(class_scope:openmldb.common.DbTableNamePair)
 private:
  void set_has_db_name();
  void clear_has_db_name();
  void set_has_table_name();
  void clear_has_table_name();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr db_name_;
  ::google::protobuf::internal::ArenaStringPtr table_name_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ColumnDesc : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:openmldb.common.ColumnDesc) */ {
 public:
  ColumnDesc();
  virtual ~ColumnDesc();

  ColumnDesc(const ColumnDesc& from);

  inline ColumnDesc& operator=(const ColumnDesc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ColumnDesc(ColumnDesc&& from) noexcept
    : ColumnDesc() {
    *this = ::std::move(from);
  }

  inline ColumnDesc& operator=(ColumnDesc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnDesc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnDesc* internal_default_instance() {
    return reinterpret_cast<const ColumnDesc*>(
               &_ColumnDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ColumnDesc* other);
  friend void swap(ColumnDesc& a, ColumnDesc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ColumnDesc* New() const final {
    return CreateMaybeMessage<ColumnDesc>(NULL);
  }

  ColumnDesc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ColumnDesc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ColumnDesc& from);
  void MergeFrom(const ColumnDesc& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnDesc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string default_value = 5;
  bool has_default_value() const;
  void clear_default_value();
  static const int kDefaultValueFieldNumber = 5;
  const ::std::string& default_value() const;
  void set_default_value(const ::std::string& value);
  #if LANG_CXX11
  void set_default_value(::std::string&& value);
  #endif
  void set_default_value(const char* value);
  void set_default_value(const char* value, size_t size);
  ::std::string* mutable_default_value();
  ::std::string* release_default_value();
  void set_allocated_default_value(::std::string* default_value);

  // optional bool not_null = 3 [default = false];
  bool has_not_null() const;
  void clear_not_null();
  static const int kNotNullFieldNumber = 3;
  bool not_null() const;
  void set_not_null(bool value);

  // optional bool is_constant = 4 [default = false];
  bool has_is_constant() const;
  void clear_is_constant();
  static const int kIsConstantFieldNumber = 4;
  bool is_constant() const;
  void set_is_constant(bool value);

  // optional .openmldb.type.DataType data_type = 2;
  bool has_data_type() const;
  void clear_data_type();
  static const int kDataTypeFieldNumber = 2;
  ::openmldb::type::DataType data_type() const;
  void set_data_type(::openmldb::type::DataType value);

  // @@protoc_insertion_point(class_scope:openmldb.common.ColumnDesc)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_data_type();
  void clear_has_data_type();
  void set_has_not_null();
  void clear_has_not_null();
  void set_has_is_constant();
  void clear_has_is_constant();
  void set_has_default_value();
  void clear_has_default_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr default_value_;
  bool not_null_;
  bool is_constant_;
  int data_type_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TTLSt : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:openmldb.common.TTLSt) */ {
 public:
  TTLSt();
  virtual ~TTLSt();

  TTLSt(const TTLSt& from);

  inline TTLSt& operator=(const TTLSt& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TTLSt(TTLSt&& from) noexcept
    : TTLSt() {
    *this = ::std::move(from);
  }

  inline TTLSt& operator=(TTLSt&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TTLSt& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TTLSt* internal_default_instance() {
    return reinterpret_cast<const TTLSt*>(
               &_TTLSt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TTLSt* other);
  friend void swap(TTLSt& a, TTLSt& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TTLSt* New() const final {
    return CreateMaybeMessage<TTLSt>(NULL);
  }

  TTLSt* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TTLSt>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TTLSt& from);
  void MergeFrom(const TTLSt& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TTLSt* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 abs_ttl = 2 [default = 0];
  bool has_abs_ttl() const;
  void clear_abs_ttl();
  static const int kAbsTtlFieldNumber = 2;
  ::google::protobuf::uint64 abs_ttl() const;
  void set_abs_ttl(::google::protobuf::uint64 value);

  // optional uint64 lat_ttl = 3 [default = 0];
  bool has_lat_ttl() const;
  void clear_lat_ttl();
  static const int kLatTtlFieldNumber = 3;
  ::google::protobuf::uint64 lat_ttl() const;
  void set_lat_ttl(::google::protobuf::uint64 value);

  // optional .openmldb.type.TTLType ttl_type = 1 [default = kAbsoluteTime];
  bool has_ttl_type() const;
  void clear_ttl_type();
  static const int kTtlTypeFieldNumber = 1;
  ::openmldb::type::TTLType ttl_type() const;
  void set_ttl_type(::openmldb::type::TTLType value);

  // @@protoc_insertion_point(class_scope:openmldb.common.TTLSt)
 private:
  void set_has_ttl_type();
  void clear_has_ttl_type();
  void set_has_abs_ttl();
  void clear_has_abs_ttl();
  void set_has_lat_ttl();
  void clear_has_lat_ttl();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 abs_ttl_;
  ::google::protobuf::uint64 lat_ttl_;
  int ttl_type_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ColumnKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:openmldb.common.ColumnKey) */ {
 public:
  ColumnKey();
  virtual ~ColumnKey();

  ColumnKey(const ColumnKey& from);

  inline ColumnKey& operator=(const ColumnKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ColumnKey(ColumnKey&& from) noexcept
    : ColumnKey() {
    *this = ::std::move(from);
  }

  inline ColumnKey& operator=(ColumnKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnKey* internal_default_instance() {
    return reinterpret_cast<const ColumnKey*>(
               &_ColumnKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ColumnKey* other);
  friend void swap(ColumnKey& a, ColumnKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ColumnKey* New() const final {
    return CreateMaybeMessage<ColumnKey>(NULL);
  }

  ColumnKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ColumnKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ColumnKey& from);
  void MergeFrom(const ColumnKey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string col_name = 2;
  int col_name_size() const;
  void clear_col_name();
  static const int kColNameFieldNumber = 2;
  const ::std::string& col_name(int index) const;
  ::std::string* mutable_col_name(int index);
  void set_col_name(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_col_name(int index, ::std::string&& value);
  #endif
  void set_col_name(int index, const char* value);
  void set_col_name(int index, const char* value, size_t size);
  ::std::string* add_col_name();
  void add_col_name(const ::std::string& value);
  #if LANG_CXX11
  void add_col_name(::std::string&& value);
  #endif
  void add_col_name(const char* value);
  void add_col_name(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& col_name() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_col_name();

  // optional string index_name = 1;
  bool has_index_name() const;
  void clear_index_name();
  static const int kIndexNameFieldNumber = 1;
  const ::std::string& index_name() const;
  void set_index_name(const ::std::string& value);
  #if LANG_CXX11
  void set_index_name(::std::string&& value);
  #endif
  void set_index_name(const char* value);
  void set_index_name(const char* value, size_t size);
  ::std::string* mutable_index_name();
  ::std::string* release_index_name();
  void set_allocated_index_name(::std::string* index_name);

  // optional string ts_name = 3;
  bool has_ts_name() const;
  void clear_ts_name();
  static const int kTsNameFieldNumber = 3;
  const ::std::string& ts_name() const;
  void set_ts_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ts_name(::std::string&& value);
  #endif
  void set_ts_name(const char* value);
  void set_ts_name(const char* value, size_t size);
  ::std::string* mutable_ts_name();
  ::std::string* release_ts_name();
  void set_allocated_ts_name(::std::string* ts_name);

  // optional .openmldb.common.TTLSt ttl = 5;
  bool has_ttl() const;
  void clear_ttl();
  static const int kTtlFieldNumber = 5;
  private:
  const ::openmldb::common::TTLSt& _internal_ttl() const;
  public:
  const ::openmldb::common::TTLSt& ttl() const;
  ::openmldb::common::TTLSt* release_ttl();
  ::openmldb::common::TTLSt* mutable_ttl();
  void set_allocated_ttl(::openmldb::common::TTLSt* ttl);

  // optional uint32 flag = 4 [default = 0];
  bool has_flag() const;
  void clear_flag();
  static const int kFlagFieldNumber = 4;
  ::google::protobuf::uint32 flag() const;
  void set_flag(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:openmldb.common.ColumnKey)
 private:
  void set_has_index_name();
  void clear_has_index_name();
  void set_has_ts_name();
  void clear_has_ts_name();
  void set_has_flag();
  void clear_has_flag();
  void set_has_ttl();
  void clear_has_ttl();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> col_name_;
  ::google::protobuf::internal::ArenaStringPtr index_name_;
  ::google::protobuf::internal::ArenaStringPtr ts_name_;
  ::openmldb::common::TTLSt* ttl_;
  ::google::protobuf::uint32 flag_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EndpointAndTid : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:openmldb.common.EndpointAndTid) */ {
 public:
  EndpointAndTid();
  virtual ~EndpointAndTid();

  EndpointAndTid(const EndpointAndTid& from);

  inline EndpointAndTid& operator=(const EndpointAndTid& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EndpointAndTid(EndpointAndTid&& from) noexcept
    : EndpointAndTid() {
    *this = ::std::move(from);
  }

  inline EndpointAndTid& operator=(EndpointAndTid&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EndpointAndTid& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EndpointAndTid* internal_default_instance() {
    return reinterpret_cast<const EndpointAndTid*>(
               &_EndpointAndTid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(EndpointAndTid* other);
  friend void swap(EndpointAndTid& a, EndpointAndTid& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EndpointAndTid* New() const final {
    return CreateMaybeMessage<EndpointAndTid>(NULL);
  }

  EndpointAndTid* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EndpointAndTid>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EndpointAndTid& from);
  void MergeFrom(const EndpointAndTid& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EndpointAndTid* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string endpoint = 1;
  bool has_endpoint() const;
  void clear_endpoint();
  static const int kEndpointFieldNumber = 1;
  const ::std::string& endpoint() const;
  void set_endpoint(const ::std::string& value);
  #if LANG_CXX11
  void set_endpoint(::std::string&& value);
  #endif
  void set_endpoint(const char* value);
  void set_endpoint(const char* value, size_t size);
  ::std::string* mutable_endpoint();
  ::std::string* release_endpoint();
  void set_allocated_endpoint(::std::string* endpoint);

  // optional uint32 tid = 2;
  bool has_tid() const;
  void clear_tid();
  static const int kTidFieldNumber = 2;
  ::google::protobuf::uint32 tid() const;
  void set_tid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:openmldb.common.EndpointAndTid)
 private:
  void set_has_endpoint();
  void clear_has_endpoint();
  void set_has_tid();
  void clear_has_tid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr endpoint_;
  ::google::protobuf::uint32 tid_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PartitionMeta : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:openmldb.common.PartitionMeta) */ {
 public:
  PartitionMeta();
  virtual ~PartitionMeta();

  PartitionMeta(const PartitionMeta& from);

  inline PartitionMeta& operator=(const PartitionMeta& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartitionMeta(PartitionMeta&& from) noexcept
    : PartitionMeta() {
    *this = ::std::move(from);
  }

  inline PartitionMeta& operator=(PartitionMeta&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PartitionMeta& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionMeta* internal_default_instance() {
    return reinterpret_cast<const PartitionMeta*>(
               &_PartitionMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(PartitionMeta* other);
  friend void swap(PartitionMeta& a, PartitionMeta& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartitionMeta* New() const final {
    return CreateMaybeMessage<PartitionMeta>(NULL);
  }

  PartitionMeta* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PartitionMeta>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PartitionMeta& from);
  void MergeFrom(const PartitionMeta& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionMeta* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string endpoint = 1;
  bool has_endpoint() const;
  void clear_endpoint();
  static const int kEndpointFieldNumber = 1;
  const ::std::string& endpoint() const;
  void set_endpoint(const ::std::string& value);
  #if LANG_CXX11
  void set_endpoint(::std::string&& value);
  #endif
  void set_endpoint(const char* value);
  void set_endpoint(const char* value, size_t size);
  ::std::string* mutable_endpoint();
  ::std::string* release_endpoint();
  void set_allocated_endpoint(::std::string* endpoint);

  // optional bool is_leader = 2;
  bool has_is_leader() const;
  void clear_is_leader();
  static const int kIsLeaderFieldNumber = 2;
  bool is_leader() const;
  void set_is_leader(bool value);

  // optional bool is_alive = 3 [default = true];
  bool has_is_alive() const;
  void clear_is_alive();
  static const int kIsAliveFieldNumber = 3;
  bool is_alive() const;
  void set_is_alive(bool value);

  // @@protoc_insertion_point(class_scope:openmldb.common.PartitionMeta)
 private:
  void set_has_endpoint();
  void clear_has_endpoint();
  void set_has_is_leader();
  void clear_has_is_leader();
  void set_has_is_alive();
  void clear_has_is_alive();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr endpoint_;
  bool is_leader_;
  bool is_alive_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TablePartition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:openmldb.common.TablePartition) */ {
 public:
  TablePartition();
  virtual ~TablePartition();

  TablePartition(const TablePartition& from);

  inline TablePartition& operator=(const TablePartition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TablePartition(TablePartition&& from) noexcept
    : TablePartition() {
    *this = ::std::move(from);
  }

  inline TablePartition& operator=(TablePartition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TablePartition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TablePartition* internal_default_instance() {
    return reinterpret_cast<const TablePartition*>(
               &_TablePartition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(TablePartition* other);
  friend void swap(TablePartition& a, TablePartition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TablePartition* New() const final {
    return CreateMaybeMessage<TablePartition>(NULL);
  }

  TablePartition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TablePartition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TablePartition& from);
  void MergeFrom(const TablePartition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TablePartition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .openmldb.common.PartitionMeta partition_meta = 2;
  int partition_meta_size() const;
  void clear_partition_meta();
  static const int kPartitionMetaFieldNumber = 2;
  ::openmldb::common::PartitionMeta* mutable_partition_meta(int index);
  ::google::protobuf::RepeatedPtrField< ::openmldb::common::PartitionMeta >*
      mutable_partition_meta();
  const ::openmldb::common::PartitionMeta& partition_meta(int index) const;
  ::openmldb::common::PartitionMeta* add_partition_meta();
  const ::google::protobuf::RepeatedPtrField< ::openmldb::common::PartitionMeta >&
      partition_meta() const;

  // optional uint32 pid = 1;
  bool has_pid() const;
  void clear_pid();
  static const int kPidFieldNumber = 1;
  ::google::protobuf::uint32 pid() const;
  void set_pid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:openmldb.common.TablePartition)
 private:
  void set_has_pid();
  void clear_has_pid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::openmldb::common::PartitionMeta > partition_meta_;
  ::google::protobuf::uint32 pid_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CatalogInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:openmldb.common.CatalogInfo) */ {
 public:
  CatalogInfo();
  virtual ~CatalogInfo();

  CatalogInfo(const CatalogInfo& from);

  inline CatalogInfo& operator=(const CatalogInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CatalogInfo(CatalogInfo&& from) noexcept
    : CatalogInfo() {
    *this = ::std::move(from);
  }

  inline CatalogInfo& operator=(CatalogInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CatalogInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CatalogInfo* internal_default_instance() {
    return reinterpret_cast<const CatalogInfo*>(
               &_CatalogInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(CatalogInfo* other);
  friend void swap(CatalogInfo& a, CatalogInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CatalogInfo* New() const final {
    return CreateMaybeMessage<CatalogInfo>(NULL);
  }

  CatalogInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CatalogInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CatalogInfo& from);
  void MergeFrom(const CatalogInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CatalogInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string endpoint = 2;
  bool has_endpoint() const;
  void clear_endpoint();
  static const int kEndpointFieldNumber = 2;
  const ::std::string& endpoint() const;
  void set_endpoint(const ::std::string& value);
  #if LANG_CXX11
  void set_endpoint(::std::string&& value);
  #endif
  void set_endpoint(const char* value);
  void set_endpoint(const char* value, size_t size);
  ::std::string* mutable_endpoint();
  ::std::string* release_endpoint();
  void set_allocated_endpoint(::std::string* endpoint);

  // optional uint64 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint64 version() const;
  void set_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:openmldb.common.CatalogInfo)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_endpoint();
  void clear_has_endpoint();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr endpoint_;
  ::google::protobuf::uint64 version_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExternalFun : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:openmldb.common.ExternalFun) */ {
 public:
  ExternalFun();
  virtual ~ExternalFun();

  ExternalFun(const ExternalFun& from);

  inline ExternalFun& operator=(const ExternalFun& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExternalFun(ExternalFun&& from) noexcept
    : ExternalFun() {
    *this = ::std::move(from);
  }

  inline ExternalFun& operator=(ExternalFun&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExternalFun& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExternalFun* internal_default_instance() {
    return reinterpret_cast<const ExternalFun*>(
               &_ExternalFun_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ExternalFun* other);
  friend void swap(ExternalFun& a, ExternalFun& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExternalFun* New() const final {
    return CreateMaybeMessage<ExternalFun>(NULL);
  }

  ExternalFun* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExternalFun>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExternalFun& from);
  void MergeFrom(const ExternalFun& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExternalFun* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .openmldb.type.DataType arg_type = 3;
  int arg_type_size() const;
  void clear_arg_type();
  static const int kArgTypeFieldNumber = 3;
  ::openmldb::type::DataType arg_type(int index) const;
  void set_arg_type(int index, ::openmldb::type::DataType value);
  void add_arg_type(::openmldb::type::DataType value);
  const ::google::protobuf::RepeatedField<int>& arg_type() const;
  ::google::protobuf::RepeatedField<int>* mutable_arg_type();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string file = 5;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 5;
  const ::std::string& file() const;
  void set_file(const ::std::string& value);
  #if LANG_CXX11
  void set_file(::std::string&& value);
  #endif
  void set_file(const char* value);
  void set_file(const char* value, size_t size);
  ::std::string* mutable_file();
  ::std::string* release_file();
  void set_allocated_file(::std::string* file);

  // optional bool is_aggregate = 4 [default = false];
  bool has_is_aggregate() const;
  void clear_is_aggregate();
  static const int kIsAggregateFieldNumber = 4;
  bool is_aggregate() const;
  void set_is_aggregate(bool value);

  // optional .openmldb.type.DataType return_type = 2;
  bool has_return_type() const;
  void clear_return_type();
  static const int kReturnTypeFieldNumber = 2;
  ::openmldb::type::DataType return_type() const;
  void set_return_type(::openmldb::type::DataType value);

  // @@protoc_insertion_point(class_scope:openmldb.common.ExternalFun)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_return_type();
  void clear_has_return_type();
  void set_has_is_aggregate();
  void clear_has_is_aggregate();
  void set_has_file();
  void clear_has_file();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField<int> arg_type_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr file_;
  bool is_aggregate_;
  int return_type_;
  friend struct ::protobuf_common_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// KvPair

// optional int64 time = 1;
inline bool KvPair::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KvPair::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KvPair::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KvPair::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 KvPair::time() const {
  // @@protoc_insertion_point(field_get:openmldb.common.KvPair.time)
  return time_;
}
inline void KvPair::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.KvPair.time)
}

// optional bytes value = 2;
inline bool KvPair::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KvPair::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KvPair::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KvPair::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& KvPair::value() const {
  // @@protoc_insertion_point(field_get:openmldb.common.KvPair.value)
  return value_.GetNoArena();
}
inline void KvPair::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:openmldb.common.KvPair.value)
}
#if LANG_CXX11
inline void KvPair::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:openmldb.common.KvPair.value)
}
#endif
inline void KvPair::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:openmldb.common.KvPair.value)
}
inline void KvPair::set_value(const void* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:openmldb.common.KvPair.value)
}
inline ::std::string* KvPair::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:openmldb.common.KvPair.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvPair::release_value() {
  // @@protoc_insertion_point(field_release:openmldb.common.KvPair.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvPair::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:openmldb.common.KvPair.value)
}

// -------------------------------------------------------------------

// KvList

// optional string pk = 1;
inline bool KvList::has_pk() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KvList::set_has_pk() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KvList::clear_has_pk() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KvList::clear_pk() {
  pk_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pk();
}
inline const ::std::string& KvList::pk() const {
  // @@protoc_insertion_point(field_get:openmldb.common.KvList.pk)
  return pk_.GetNoArena();
}
inline void KvList::set_pk(const ::std::string& value) {
  set_has_pk();
  pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:openmldb.common.KvList.pk)
}
#if LANG_CXX11
inline void KvList::set_pk(::std::string&& value) {
  set_has_pk();
  pk_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:openmldb.common.KvList.pk)
}
#endif
inline void KvList::set_pk(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pk();
  pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:openmldb.common.KvList.pk)
}
inline void KvList::set_pk(const char* value, size_t size) {
  set_has_pk();
  pk_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:openmldb.common.KvList.pk)
}
inline ::std::string* KvList::mutable_pk() {
  set_has_pk();
  // @@protoc_insertion_point(field_mutable:openmldb.common.KvList.pk)
  return pk_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KvList::release_pk() {
  // @@protoc_insertion_point(field_release:openmldb.common.KvList.pk)
  if (!has_pk()) {
    return NULL;
  }
  clear_has_pk();
  return pk_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KvList::set_allocated_pk(::std::string* pk) {
  if (pk != NULL) {
    set_has_pk();
  } else {
    clear_has_pk();
  }
  pk_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pk);
  // @@protoc_insertion_point(field_set_allocated:openmldb.common.KvList.pk)
}

// repeated .openmldb.common.KvPair pairs = 2;
inline int KvList::pairs_size() const {
  return pairs_.size();
}
inline void KvList::clear_pairs() {
  pairs_.Clear();
}
inline ::openmldb::common::KvPair* KvList::mutable_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:openmldb.common.KvList.pairs)
  return pairs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::openmldb::common::KvPair >*
KvList::mutable_pairs() {
  // @@protoc_insertion_point(field_mutable_list:openmldb.common.KvList.pairs)
  return &pairs_;
}
inline const ::openmldb::common::KvPair& KvList::pairs(int index) const {
  // @@protoc_insertion_point(field_get:openmldb.common.KvList.pairs)
  return pairs_.Get(index);
}
inline ::openmldb::common::KvPair* KvList::add_pairs() {
  // @@protoc_insertion_point(field_add:openmldb.common.KvList.pairs)
  return pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::openmldb::common::KvPair >&
KvList::pairs() const {
  // @@protoc_insertion_point(field_list:openmldb.common.KvList.pairs)
  return pairs_;
}

// -------------------------------------------------------------------

// VersionPair

// optional int32 id = 1;
inline bool VersionPair::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VersionPair::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VersionPair::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VersionPair::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 VersionPair::id() const {
  // @@protoc_insertion_point(field_get:openmldb.common.VersionPair.id)
  return id_;
}
inline void VersionPair::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.VersionPair.id)
}

// optional int32 field_count = 2;
inline bool VersionPair::has_field_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VersionPair::set_has_field_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VersionPair::clear_has_field_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VersionPair::clear_field_count() {
  field_count_ = 0;
  clear_has_field_count();
}
inline ::google::protobuf::int32 VersionPair::field_count() const {
  // @@protoc_insertion_point(field_get:openmldb.common.VersionPair.field_count)
  return field_count_;
}
inline void VersionPair::set_field_count(::google::protobuf::int32 value) {
  set_has_field_count();
  field_count_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.VersionPair.field_count)
}

// -------------------------------------------------------------------

// DbTableNamePair

// required string db_name = 1;
inline bool DbTableNamePair::has_db_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DbTableNamePair::set_has_db_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DbTableNamePair::clear_has_db_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DbTableNamePair::clear_db_name() {
  db_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_db_name();
}
inline const ::std::string& DbTableNamePair::db_name() const {
  // @@protoc_insertion_point(field_get:openmldb.common.DbTableNamePair.db_name)
  return db_name_.GetNoArena();
}
inline void DbTableNamePair::set_db_name(const ::std::string& value) {
  set_has_db_name();
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:openmldb.common.DbTableNamePair.db_name)
}
#if LANG_CXX11
inline void DbTableNamePair::set_db_name(::std::string&& value) {
  set_has_db_name();
  db_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:openmldb.common.DbTableNamePair.db_name)
}
#endif
inline void DbTableNamePair::set_db_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_db_name();
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:openmldb.common.DbTableNamePair.db_name)
}
inline void DbTableNamePair::set_db_name(const char* value, size_t size) {
  set_has_db_name();
  db_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:openmldb.common.DbTableNamePair.db_name)
}
inline ::std::string* DbTableNamePair::mutable_db_name() {
  set_has_db_name();
  // @@protoc_insertion_point(field_mutable:openmldb.common.DbTableNamePair.db_name)
  return db_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DbTableNamePair::release_db_name() {
  // @@protoc_insertion_point(field_release:openmldb.common.DbTableNamePair.db_name)
  if (!has_db_name()) {
    return NULL;
  }
  clear_has_db_name();
  return db_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DbTableNamePair::set_allocated_db_name(::std::string* db_name) {
  if (db_name != NULL) {
    set_has_db_name();
  } else {
    clear_has_db_name();
  }
  db_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_name);
  // @@protoc_insertion_point(field_set_allocated:openmldb.common.DbTableNamePair.db_name)
}

// required string table_name = 2;
inline bool DbTableNamePair::has_table_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DbTableNamePair::set_has_table_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DbTableNamePair::clear_has_table_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DbTableNamePair::clear_table_name() {
  table_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_table_name();
}
inline const ::std::string& DbTableNamePair::table_name() const {
  // @@protoc_insertion_point(field_get:openmldb.common.DbTableNamePair.table_name)
  return table_name_.GetNoArena();
}
inline void DbTableNamePair::set_table_name(const ::std::string& value) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:openmldb.common.DbTableNamePair.table_name)
}
#if LANG_CXX11
inline void DbTableNamePair::set_table_name(::std::string&& value) {
  set_has_table_name();
  table_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:openmldb.common.DbTableNamePair.table_name)
}
#endif
inline void DbTableNamePair::set_table_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:openmldb.common.DbTableNamePair.table_name)
}
inline void DbTableNamePair::set_table_name(const char* value, size_t size) {
  set_has_table_name();
  table_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:openmldb.common.DbTableNamePair.table_name)
}
inline ::std::string* DbTableNamePair::mutable_table_name() {
  set_has_table_name();
  // @@protoc_insertion_point(field_mutable:openmldb.common.DbTableNamePair.table_name)
  return table_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DbTableNamePair::release_table_name() {
  // @@protoc_insertion_point(field_release:openmldb.common.DbTableNamePair.table_name)
  if (!has_table_name()) {
    return NULL;
  }
  clear_has_table_name();
  return table_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DbTableNamePair::set_allocated_table_name(::std::string* table_name) {
  if (table_name != NULL) {
    set_has_table_name();
  } else {
    clear_has_table_name();
  }
  table_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_name);
  // @@protoc_insertion_point(field_set_allocated:openmldb.common.DbTableNamePair.table_name)
}

// -------------------------------------------------------------------

// ColumnDesc

// required string name = 1;
inline bool ColumnDesc::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnDesc::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnDesc::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnDesc::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ColumnDesc::name() const {
  // @@protoc_insertion_point(field_get:openmldb.common.ColumnDesc.name)
  return name_.GetNoArena();
}
inline void ColumnDesc::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:openmldb.common.ColumnDesc.name)
}
#if LANG_CXX11
inline void ColumnDesc::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:openmldb.common.ColumnDesc.name)
}
#endif
inline void ColumnDesc::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:openmldb.common.ColumnDesc.name)
}
inline void ColumnDesc::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:openmldb.common.ColumnDesc.name)
}
inline ::std::string* ColumnDesc::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:openmldb.common.ColumnDesc.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnDesc::release_name() {
  // @@protoc_insertion_point(field_release:openmldb.common.ColumnDesc.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnDesc::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:openmldb.common.ColumnDesc.name)
}

// optional .openmldb.type.DataType data_type = 2;
inline bool ColumnDesc::has_data_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ColumnDesc::set_has_data_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ColumnDesc::clear_has_data_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ColumnDesc::clear_data_type() {
  data_type_ = 1;
  clear_has_data_type();
}
inline ::openmldb::type::DataType ColumnDesc::data_type() const {
  // @@protoc_insertion_point(field_get:openmldb.common.ColumnDesc.data_type)
  return static_cast< ::openmldb::type::DataType >(data_type_);
}
inline void ColumnDesc::set_data_type(::openmldb::type::DataType value) {
  assert(::openmldb::type::DataType_IsValid(value));
  set_has_data_type();
  data_type_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.ColumnDesc.data_type)
}

// optional bool not_null = 3 [default = false];
inline bool ColumnDesc::has_not_null() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnDesc::set_has_not_null() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColumnDesc::clear_has_not_null() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColumnDesc::clear_not_null() {
  not_null_ = false;
  clear_has_not_null();
}
inline bool ColumnDesc::not_null() const {
  // @@protoc_insertion_point(field_get:openmldb.common.ColumnDesc.not_null)
  return not_null_;
}
inline void ColumnDesc::set_not_null(bool value) {
  set_has_not_null();
  not_null_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.ColumnDesc.not_null)
}

// optional bool is_constant = 4 [default = false];
inline bool ColumnDesc::has_is_constant() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ColumnDesc::set_has_is_constant() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ColumnDesc::clear_has_is_constant() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ColumnDesc::clear_is_constant() {
  is_constant_ = false;
  clear_has_is_constant();
}
inline bool ColumnDesc::is_constant() const {
  // @@protoc_insertion_point(field_get:openmldb.common.ColumnDesc.is_constant)
  return is_constant_;
}
inline void ColumnDesc::set_is_constant(bool value) {
  set_has_is_constant();
  is_constant_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.ColumnDesc.is_constant)
}

// optional string default_value = 5;
inline bool ColumnDesc::has_default_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnDesc::set_has_default_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnDesc::clear_has_default_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnDesc::clear_default_value() {
  default_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_default_value();
}
inline const ::std::string& ColumnDesc::default_value() const {
  // @@protoc_insertion_point(field_get:openmldb.common.ColumnDesc.default_value)
  return default_value_.GetNoArena();
}
inline void ColumnDesc::set_default_value(const ::std::string& value) {
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:openmldb.common.ColumnDesc.default_value)
}
#if LANG_CXX11
inline void ColumnDesc::set_default_value(::std::string&& value) {
  set_has_default_value();
  default_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:openmldb.common.ColumnDesc.default_value)
}
#endif
inline void ColumnDesc::set_default_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:openmldb.common.ColumnDesc.default_value)
}
inline void ColumnDesc::set_default_value(const char* value, size_t size) {
  set_has_default_value();
  default_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:openmldb.common.ColumnDesc.default_value)
}
inline ::std::string* ColumnDesc::mutable_default_value() {
  set_has_default_value();
  // @@protoc_insertion_point(field_mutable:openmldb.common.ColumnDesc.default_value)
  return default_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnDesc::release_default_value() {
  // @@protoc_insertion_point(field_release:openmldb.common.ColumnDesc.default_value)
  if (!has_default_value()) {
    return NULL;
  }
  clear_has_default_value();
  return default_value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnDesc::set_allocated_default_value(::std::string* default_value) {
  if (default_value != NULL) {
    set_has_default_value();
  } else {
    clear_has_default_value();
  }
  default_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), default_value);
  // @@protoc_insertion_point(field_set_allocated:openmldb.common.ColumnDesc.default_value)
}

// -------------------------------------------------------------------

// TTLSt

// optional .openmldb.type.TTLType ttl_type = 1 [default = kAbsoluteTime];
inline bool TTLSt::has_ttl_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TTLSt::set_has_ttl_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TTLSt::clear_has_ttl_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TTLSt::clear_ttl_type() {
  ttl_type_ = 1;
  clear_has_ttl_type();
}
inline ::openmldb::type::TTLType TTLSt::ttl_type() const {
  // @@protoc_insertion_point(field_get:openmldb.common.TTLSt.ttl_type)
  return static_cast< ::openmldb::type::TTLType >(ttl_type_);
}
inline void TTLSt::set_ttl_type(::openmldb::type::TTLType value) {
  assert(::openmldb::type::TTLType_IsValid(value));
  set_has_ttl_type();
  ttl_type_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.TTLSt.ttl_type)
}

// optional uint64 abs_ttl = 2 [default = 0];
inline bool TTLSt::has_abs_ttl() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TTLSt::set_has_abs_ttl() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TTLSt::clear_has_abs_ttl() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TTLSt::clear_abs_ttl() {
  abs_ttl_ = GOOGLE_ULONGLONG(0);
  clear_has_abs_ttl();
}
inline ::google::protobuf::uint64 TTLSt::abs_ttl() const {
  // @@protoc_insertion_point(field_get:openmldb.common.TTLSt.abs_ttl)
  return abs_ttl_;
}
inline void TTLSt::set_abs_ttl(::google::protobuf::uint64 value) {
  set_has_abs_ttl();
  abs_ttl_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.TTLSt.abs_ttl)
}

// optional uint64 lat_ttl = 3 [default = 0];
inline bool TTLSt::has_lat_ttl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TTLSt::set_has_lat_ttl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TTLSt::clear_has_lat_ttl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TTLSt::clear_lat_ttl() {
  lat_ttl_ = GOOGLE_ULONGLONG(0);
  clear_has_lat_ttl();
}
inline ::google::protobuf::uint64 TTLSt::lat_ttl() const {
  // @@protoc_insertion_point(field_get:openmldb.common.TTLSt.lat_ttl)
  return lat_ttl_;
}
inline void TTLSt::set_lat_ttl(::google::protobuf::uint64 value) {
  set_has_lat_ttl();
  lat_ttl_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.TTLSt.lat_ttl)
}

// -------------------------------------------------------------------

// ColumnKey

// optional string index_name = 1;
inline bool ColumnKey::has_index_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnKey::set_has_index_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnKey::clear_has_index_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnKey::clear_index_name() {
  index_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_index_name();
}
inline const ::std::string& ColumnKey::index_name() const {
  // @@protoc_insertion_point(field_get:openmldb.common.ColumnKey.index_name)
  return index_name_.GetNoArena();
}
inline void ColumnKey::set_index_name(const ::std::string& value) {
  set_has_index_name();
  index_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:openmldb.common.ColumnKey.index_name)
}
#if LANG_CXX11
inline void ColumnKey::set_index_name(::std::string&& value) {
  set_has_index_name();
  index_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:openmldb.common.ColumnKey.index_name)
}
#endif
inline void ColumnKey::set_index_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_index_name();
  index_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:openmldb.common.ColumnKey.index_name)
}
inline void ColumnKey::set_index_name(const char* value, size_t size) {
  set_has_index_name();
  index_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:openmldb.common.ColumnKey.index_name)
}
inline ::std::string* ColumnKey::mutable_index_name() {
  set_has_index_name();
  // @@protoc_insertion_point(field_mutable:openmldb.common.ColumnKey.index_name)
  return index_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnKey::release_index_name() {
  // @@protoc_insertion_point(field_release:openmldb.common.ColumnKey.index_name)
  if (!has_index_name()) {
    return NULL;
  }
  clear_has_index_name();
  return index_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnKey::set_allocated_index_name(::std::string* index_name) {
  if (index_name != NULL) {
    set_has_index_name();
  } else {
    clear_has_index_name();
  }
  index_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), index_name);
  // @@protoc_insertion_point(field_set_allocated:openmldb.common.ColumnKey.index_name)
}

// repeated string col_name = 2;
inline int ColumnKey::col_name_size() const {
  return col_name_.size();
}
inline void ColumnKey::clear_col_name() {
  col_name_.Clear();
}
inline const ::std::string& ColumnKey::col_name(int index) const {
  // @@protoc_insertion_point(field_get:openmldb.common.ColumnKey.col_name)
  return col_name_.Get(index);
}
inline ::std::string* ColumnKey::mutable_col_name(int index) {
  // @@protoc_insertion_point(field_mutable:openmldb.common.ColumnKey.col_name)
  return col_name_.Mutable(index);
}
inline void ColumnKey::set_col_name(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:openmldb.common.ColumnKey.col_name)
  col_name_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ColumnKey::set_col_name(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:openmldb.common.ColumnKey.col_name)
  col_name_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ColumnKey::set_col_name(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  col_name_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:openmldb.common.ColumnKey.col_name)
}
inline void ColumnKey::set_col_name(int index, const char* value, size_t size) {
  col_name_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:openmldb.common.ColumnKey.col_name)
}
inline ::std::string* ColumnKey::add_col_name() {
  // @@protoc_insertion_point(field_add_mutable:openmldb.common.ColumnKey.col_name)
  return col_name_.Add();
}
inline void ColumnKey::add_col_name(const ::std::string& value) {
  col_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:openmldb.common.ColumnKey.col_name)
}
#if LANG_CXX11
inline void ColumnKey::add_col_name(::std::string&& value) {
  col_name_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:openmldb.common.ColumnKey.col_name)
}
#endif
inline void ColumnKey::add_col_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  col_name_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:openmldb.common.ColumnKey.col_name)
}
inline void ColumnKey::add_col_name(const char* value, size_t size) {
  col_name_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:openmldb.common.ColumnKey.col_name)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ColumnKey::col_name() const {
  // @@protoc_insertion_point(field_list:openmldb.common.ColumnKey.col_name)
  return col_name_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ColumnKey::mutable_col_name() {
  // @@protoc_insertion_point(field_mutable_list:openmldb.common.ColumnKey.col_name)
  return &col_name_;
}

// optional string ts_name = 3;
inline bool ColumnKey::has_ts_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnKey::set_has_ts_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnKey::clear_has_ts_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnKey::clear_ts_name() {
  ts_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ts_name();
}
inline const ::std::string& ColumnKey::ts_name() const {
  // @@protoc_insertion_point(field_get:openmldb.common.ColumnKey.ts_name)
  return ts_name_.GetNoArena();
}
inline void ColumnKey::set_ts_name(const ::std::string& value) {
  set_has_ts_name();
  ts_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:openmldb.common.ColumnKey.ts_name)
}
#if LANG_CXX11
inline void ColumnKey::set_ts_name(::std::string&& value) {
  set_has_ts_name();
  ts_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:openmldb.common.ColumnKey.ts_name)
}
#endif
inline void ColumnKey::set_ts_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ts_name();
  ts_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:openmldb.common.ColumnKey.ts_name)
}
inline void ColumnKey::set_ts_name(const char* value, size_t size) {
  set_has_ts_name();
  ts_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:openmldb.common.ColumnKey.ts_name)
}
inline ::std::string* ColumnKey::mutable_ts_name() {
  set_has_ts_name();
  // @@protoc_insertion_point(field_mutable:openmldb.common.ColumnKey.ts_name)
  return ts_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnKey::release_ts_name() {
  // @@protoc_insertion_point(field_release:openmldb.common.ColumnKey.ts_name)
  if (!has_ts_name()) {
    return NULL;
  }
  clear_has_ts_name();
  return ts_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnKey::set_allocated_ts_name(::std::string* ts_name) {
  if (ts_name != NULL) {
    set_has_ts_name();
  } else {
    clear_has_ts_name();
  }
  ts_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ts_name);
  // @@protoc_insertion_point(field_set_allocated:openmldb.common.ColumnKey.ts_name)
}

// optional uint32 flag = 4 [default = 0];
inline bool ColumnKey::has_flag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ColumnKey::set_has_flag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ColumnKey::clear_has_flag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ColumnKey::clear_flag() {
  flag_ = 0u;
  clear_has_flag();
}
inline ::google::protobuf::uint32 ColumnKey::flag() const {
  // @@protoc_insertion_point(field_get:openmldb.common.ColumnKey.flag)
  return flag_;
}
inline void ColumnKey::set_flag(::google::protobuf::uint32 value) {
  set_has_flag();
  flag_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.ColumnKey.flag)
}

// optional .openmldb.common.TTLSt ttl = 5;
inline bool ColumnKey::has_ttl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnKey::set_has_ttl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColumnKey::clear_has_ttl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColumnKey::clear_ttl() {
  if (ttl_ != NULL) ttl_->Clear();
  clear_has_ttl();
}
inline const ::openmldb::common::TTLSt& ColumnKey::_internal_ttl() const {
  return *ttl_;
}
inline const ::openmldb::common::TTLSt& ColumnKey::ttl() const {
  const ::openmldb::common::TTLSt* p = ttl_;
  // @@protoc_insertion_point(field_get:openmldb.common.ColumnKey.ttl)
  return p != NULL ? *p : *reinterpret_cast<const ::openmldb::common::TTLSt*>(
      &::openmldb::common::_TTLSt_default_instance_);
}
inline ::openmldb::common::TTLSt* ColumnKey::release_ttl() {
  // @@protoc_insertion_point(field_release:openmldb.common.ColumnKey.ttl)
  clear_has_ttl();
  ::openmldb::common::TTLSt* temp = ttl_;
  ttl_ = NULL;
  return temp;
}
inline ::openmldb::common::TTLSt* ColumnKey::mutable_ttl() {
  set_has_ttl();
  if (ttl_ == NULL) {
    auto* p = CreateMaybeMessage<::openmldb::common::TTLSt>(GetArenaNoVirtual());
    ttl_ = p;
  }
  // @@protoc_insertion_point(field_mutable:openmldb.common.ColumnKey.ttl)
  return ttl_;
}
inline void ColumnKey::set_allocated_ttl(::openmldb::common::TTLSt* ttl) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ttl_;
  }
  if (ttl) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ttl = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ttl, submessage_arena);
    }
    set_has_ttl();
  } else {
    clear_has_ttl();
  }
  ttl_ = ttl;
  // @@protoc_insertion_point(field_set_allocated:openmldb.common.ColumnKey.ttl)
}

// -------------------------------------------------------------------

// EndpointAndTid

// optional string endpoint = 1;
inline bool EndpointAndTid::has_endpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EndpointAndTid::set_has_endpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EndpointAndTid::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EndpointAndTid::clear_endpoint() {
  endpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_endpoint();
}
inline const ::std::string& EndpointAndTid::endpoint() const {
  // @@protoc_insertion_point(field_get:openmldb.common.EndpointAndTid.endpoint)
  return endpoint_.GetNoArena();
}
inline void EndpointAndTid::set_endpoint(const ::std::string& value) {
  set_has_endpoint();
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:openmldb.common.EndpointAndTid.endpoint)
}
#if LANG_CXX11
inline void EndpointAndTid::set_endpoint(::std::string&& value) {
  set_has_endpoint();
  endpoint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:openmldb.common.EndpointAndTid.endpoint)
}
#endif
inline void EndpointAndTid::set_endpoint(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_endpoint();
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:openmldb.common.EndpointAndTid.endpoint)
}
inline void EndpointAndTid::set_endpoint(const char* value, size_t size) {
  set_has_endpoint();
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:openmldb.common.EndpointAndTid.endpoint)
}
inline ::std::string* EndpointAndTid::mutable_endpoint() {
  set_has_endpoint();
  // @@protoc_insertion_point(field_mutable:openmldb.common.EndpointAndTid.endpoint)
  return endpoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EndpointAndTid::release_endpoint() {
  // @@protoc_insertion_point(field_release:openmldb.common.EndpointAndTid.endpoint)
  if (!has_endpoint()) {
    return NULL;
  }
  clear_has_endpoint();
  return endpoint_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EndpointAndTid::set_allocated_endpoint(::std::string* endpoint) {
  if (endpoint != NULL) {
    set_has_endpoint();
  } else {
    clear_has_endpoint();
  }
  endpoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), endpoint);
  // @@protoc_insertion_point(field_set_allocated:openmldb.common.EndpointAndTid.endpoint)
}

// optional uint32 tid = 2;
inline bool EndpointAndTid::has_tid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EndpointAndTid::set_has_tid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EndpointAndTid::clear_has_tid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EndpointAndTid::clear_tid() {
  tid_ = 0u;
  clear_has_tid();
}
inline ::google::protobuf::uint32 EndpointAndTid::tid() const {
  // @@protoc_insertion_point(field_get:openmldb.common.EndpointAndTid.tid)
  return tid_;
}
inline void EndpointAndTid::set_tid(::google::protobuf::uint32 value) {
  set_has_tid();
  tid_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.EndpointAndTid.tid)
}

// -------------------------------------------------------------------

// PartitionMeta

// optional string endpoint = 1;
inline bool PartitionMeta::has_endpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartitionMeta::set_has_endpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PartitionMeta::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PartitionMeta::clear_endpoint() {
  endpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_endpoint();
}
inline const ::std::string& PartitionMeta::endpoint() const {
  // @@protoc_insertion_point(field_get:openmldb.common.PartitionMeta.endpoint)
  return endpoint_.GetNoArena();
}
inline void PartitionMeta::set_endpoint(const ::std::string& value) {
  set_has_endpoint();
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:openmldb.common.PartitionMeta.endpoint)
}
#if LANG_CXX11
inline void PartitionMeta::set_endpoint(::std::string&& value) {
  set_has_endpoint();
  endpoint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:openmldb.common.PartitionMeta.endpoint)
}
#endif
inline void PartitionMeta::set_endpoint(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_endpoint();
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:openmldb.common.PartitionMeta.endpoint)
}
inline void PartitionMeta::set_endpoint(const char* value, size_t size) {
  set_has_endpoint();
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:openmldb.common.PartitionMeta.endpoint)
}
inline ::std::string* PartitionMeta::mutable_endpoint() {
  set_has_endpoint();
  // @@protoc_insertion_point(field_mutable:openmldb.common.PartitionMeta.endpoint)
  return endpoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionMeta::release_endpoint() {
  // @@protoc_insertion_point(field_release:openmldb.common.PartitionMeta.endpoint)
  if (!has_endpoint()) {
    return NULL;
  }
  clear_has_endpoint();
  return endpoint_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionMeta::set_allocated_endpoint(::std::string* endpoint) {
  if (endpoint != NULL) {
    set_has_endpoint();
  } else {
    clear_has_endpoint();
  }
  endpoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), endpoint);
  // @@protoc_insertion_point(field_set_allocated:openmldb.common.PartitionMeta.endpoint)
}

// optional bool is_leader = 2;
inline bool PartitionMeta::has_is_leader() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartitionMeta::set_has_is_leader() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PartitionMeta::clear_has_is_leader() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PartitionMeta::clear_is_leader() {
  is_leader_ = false;
  clear_has_is_leader();
}
inline bool PartitionMeta::is_leader() const {
  // @@protoc_insertion_point(field_get:openmldb.common.PartitionMeta.is_leader)
  return is_leader_;
}
inline void PartitionMeta::set_is_leader(bool value) {
  set_has_is_leader();
  is_leader_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.PartitionMeta.is_leader)
}

// optional bool is_alive = 3 [default = true];
inline bool PartitionMeta::has_is_alive() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PartitionMeta::set_has_is_alive() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PartitionMeta::clear_has_is_alive() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PartitionMeta::clear_is_alive() {
  is_alive_ = true;
  clear_has_is_alive();
}
inline bool PartitionMeta::is_alive() const {
  // @@protoc_insertion_point(field_get:openmldb.common.PartitionMeta.is_alive)
  return is_alive_;
}
inline void PartitionMeta::set_is_alive(bool value) {
  set_has_is_alive();
  is_alive_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.PartitionMeta.is_alive)
}

// -------------------------------------------------------------------

// TablePartition

// optional uint32 pid = 1;
inline bool TablePartition::has_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TablePartition::set_has_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TablePartition::clear_has_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TablePartition::clear_pid() {
  pid_ = 0u;
  clear_has_pid();
}
inline ::google::protobuf::uint32 TablePartition::pid() const {
  // @@protoc_insertion_point(field_get:openmldb.common.TablePartition.pid)
  return pid_;
}
inline void TablePartition::set_pid(::google::protobuf::uint32 value) {
  set_has_pid();
  pid_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.TablePartition.pid)
}

// repeated .openmldb.common.PartitionMeta partition_meta = 2;
inline int TablePartition::partition_meta_size() const {
  return partition_meta_.size();
}
inline void TablePartition::clear_partition_meta() {
  partition_meta_.Clear();
}
inline ::openmldb::common::PartitionMeta* TablePartition::mutable_partition_meta(int index) {
  // @@protoc_insertion_point(field_mutable:openmldb.common.TablePartition.partition_meta)
  return partition_meta_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::openmldb::common::PartitionMeta >*
TablePartition::mutable_partition_meta() {
  // @@protoc_insertion_point(field_mutable_list:openmldb.common.TablePartition.partition_meta)
  return &partition_meta_;
}
inline const ::openmldb::common::PartitionMeta& TablePartition::partition_meta(int index) const {
  // @@protoc_insertion_point(field_get:openmldb.common.TablePartition.partition_meta)
  return partition_meta_.Get(index);
}
inline ::openmldb::common::PartitionMeta* TablePartition::add_partition_meta() {
  // @@protoc_insertion_point(field_add:openmldb.common.TablePartition.partition_meta)
  return partition_meta_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::openmldb::common::PartitionMeta >&
TablePartition::partition_meta() const {
  // @@protoc_insertion_point(field_list:openmldb.common.TablePartition.partition_meta)
  return partition_meta_;
}

// -------------------------------------------------------------------

// CatalogInfo

// optional uint64 version = 1;
inline bool CatalogInfo::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CatalogInfo::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CatalogInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CatalogInfo::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::uint64 CatalogInfo::version() const {
  // @@protoc_insertion_point(field_get:openmldb.common.CatalogInfo.version)
  return version_;
}
inline void CatalogInfo::set_version(::google::protobuf::uint64 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.CatalogInfo.version)
}

// optional string endpoint = 2;
inline bool CatalogInfo::has_endpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CatalogInfo::set_has_endpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CatalogInfo::clear_has_endpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CatalogInfo::clear_endpoint() {
  endpoint_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_endpoint();
}
inline const ::std::string& CatalogInfo::endpoint() const {
  // @@protoc_insertion_point(field_get:openmldb.common.CatalogInfo.endpoint)
  return endpoint_.GetNoArena();
}
inline void CatalogInfo::set_endpoint(const ::std::string& value) {
  set_has_endpoint();
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:openmldb.common.CatalogInfo.endpoint)
}
#if LANG_CXX11
inline void CatalogInfo::set_endpoint(::std::string&& value) {
  set_has_endpoint();
  endpoint_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:openmldb.common.CatalogInfo.endpoint)
}
#endif
inline void CatalogInfo::set_endpoint(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_endpoint();
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:openmldb.common.CatalogInfo.endpoint)
}
inline void CatalogInfo::set_endpoint(const char* value, size_t size) {
  set_has_endpoint();
  endpoint_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:openmldb.common.CatalogInfo.endpoint)
}
inline ::std::string* CatalogInfo::mutable_endpoint() {
  set_has_endpoint();
  // @@protoc_insertion_point(field_mutable:openmldb.common.CatalogInfo.endpoint)
  return endpoint_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CatalogInfo::release_endpoint() {
  // @@protoc_insertion_point(field_release:openmldb.common.CatalogInfo.endpoint)
  if (!has_endpoint()) {
    return NULL;
  }
  clear_has_endpoint();
  return endpoint_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CatalogInfo::set_allocated_endpoint(::std::string* endpoint) {
  if (endpoint != NULL) {
    set_has_endpoint();
  } else {
    clear_has_endpoint();
  }
  endpoint_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), endpoint);
  // @@protoc_insertion_point(field_set_allocated:openmldb.common.CatalogInfo.endpoint)
}

// -------------------------------------------------------------------

// ExternalFun

// optional string name = 1;
inline bool ExternalFun::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExternalFun::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExternalFun::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExternalFun::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ExternalFun::name() const {
  // @@protoc_insertion_point(field_get:openmldb.common.ExternalFun.name)
  return name_.GetNoArena();
}
inline void ExternalFun::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:openmldb.common.ExternalFun.name)
}
#if LANG_CXX11
inline void ExternalFun::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:openmldb.common.ExternalFun.name)
}
#endif
inline void ExternalFun::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:openmldb.common.ExternalFun.name)
}
inline void ExternalFun::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:openmldb.common.ExternalFun.name)
}
inline ::std::string* ExternalFun::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:openmldb.common.ExternalFun.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExternalFun::release_name() {
  // @@protoc_insertion_point(field_release:openmldb.common.ExternalFun.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExternalFun::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:openmldb.common.ExternalFun.name)
}

// optional .openmldb.type.DataType return_type = 2;
inline bool ExternalFun::has_return_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExternalFun::set_has_return_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExternalFun::clear_has_return_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExternalFun::clear_return_type() {
  return_type_ = 1;
  clear_has_return_type();
}
inline ::openmldb::type::DataType ExternalFun::return_type() const {
  // @@protoc_insertion_point(field_get:openmldb.common.ExternalFun.return_type)
  return static_cast< ::openmldb::type::DataType >(return_type_);
}
inline void ExternalFun::set_return_type(::openmldb::type::DataType value) {
  assert(::openmldb::type::DataType_IsValid(value));
  set_has_return_type();
  return_type_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.ExternalFun.return_type)
}

// repeated .openmldb.type.DataType arg_type = 3;
inline int ExternalFun::arg_type_size() const {
  return arg_type_.size();
}
inline void ExternalFun::clear_arg_type() {
  arg_type_.Clear();
}
inline ::openmldb::type::DataType ExternalFun::arg_type(int index) const {
  // @@protoc_insertion_point(field_get:openmldb.common.ExternalFun.arg_type)
  return static_cast< ::openmldb::type::DataType >(arg_type_.Get(index));
}
inline void ExternalFun::set_arg_type(int index, ::openmldb::type::DataType value) {
  assert(::openmldb::type::DataType_IsValid(value));
  arg_type_.Set(index, value);
  // @@protoc_insertion_point(field_set:openmldb.common.ExternalFun.arg_type)
}
inline void ExternalFun::add_arg_type(::openmldb::type::DataType value) {
  assert(::openmldb::type::DataType_IsValid(value));
  arg_type_.Add(value);
  // @@protoc_insertion_point(field_add:openmldb.common.ExternalFun.arg_type)
}
inline const ::google::protobuf::RepeatedField<int>&
ExternalFun::arg_type() const {
  // @@protoc_insertion_point(field_list:openmldb.common.ExternalFun.arg_type)
  return arg_type_;
}
inline ::google::protobuf::RepeatedField<int>*
ExternalFun::mutable_arg_type() {
  // @@protoc_insertion_point(field_mutable_list:openmldb.common.ExternalFun.arg_type)
  return &arg_type_;
}

// optional bool is_aggregate = 4 [default = false];
inline bool ExternalFun::has_is_aggregate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExternalFun::set_has_is_aggregate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExternalFun::clear_has_is_aggregate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExternalFun::clear_is_aggregate() {
  is_aggregate_ = false;
  clear_has_is_aggregate();
}
inline bool ExternalFun::is_aggregate() const {
  // @@protoc_insertion_point(field_get:openmldb.common.ExternalFun.is_aggregate)
  return is_aggregate_;
}
inline void ExternalFun::set_is_aggregate(bool value) {
  set_has_is_aggregate();
  is_aggregate_ = value;
  // @@protoc_insertion_point(field_set:openmldb.common.ExternalFun.is_aggregate)
}

// optional string file = 5;
inline bool ExternalFun::has_file() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExternalFun::set_has_file() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExternalFun::clear_has_file() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExternalFun::clear_file() {
  file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_file();
}
inline const ::std::string& ExternalFun::file() const {
  // @@protoc_insertion_point(field_get:openmldb.common.ExternalFun.file)
  return file_.GetNoArena();
}
inline void ExternalFun::set_file(const ::std::string& value) {
  set_has_file();
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:openmldb.common.ExternalFun.file)
}
#if LANG_CXX11
inline void ExternalFun::set_file(::std::string&& value) {
  set_has_file();
  file_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:openmldb.common.ExternalFun.file)
}
#endif
inline void ExternalFun::set_file(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_file();
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:openmldb.common.ExternalFun.file)
}
inline void ExternalFun::set_file(const char* value, size_t size) {
  set_has_file();
  file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:openmldb.common.ExternalFun.file)
}
inline ::std::string* ExternalFun::mutable_file() {
  set_has_file();
  // @@protoc_insertion_point(field_mutable:openmldb.common.ExternalFun.file)
  return file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExternalFun::release_file() {
  // @@protoc_insertion_point(field_release:openmldb.common.ExternalFun.file)
  if (!has_file()) {
    return NULL;
  }
  clear_has_file();
  return file_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExternalFun::set_allocated_file(::std::string* file) {
  if (file != NULL) {
    set_has_file();
  } else {
    clear_has_file();
  }
  file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file);
  // @@protoc_insertion_point(field_set_allocated:openmldb.common.ExternalFun.file)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace common
}  // namespace openmldb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::openmldb::common::StorageMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::openmldb::common::StorageMode>() {
  return ::openmldb::common::StorageMode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_common_2eproto
