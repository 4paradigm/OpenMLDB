// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fe_type.proto

#ifndef PROTOBUF_INCLUDED_fe_5ftype_2eproto
#define PROTOBUF_INCLUDED_fe_5ftype_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_fe_5ftype_2eproto 

namespace protobuf_fe_5ftype_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[7];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_fe_5ftype_2eproto
namespace hybridse {
namespace type {
class CataLog;
class CataLogDefaultTypeInternal;
extern CataLogDefaultTypeInternal _CataLog_default_instance_;
class ColumnDef;
class ColumnDefDefaultTypeInternal;
extern ColumnDefDefaultTypeInternal _ColumnDef_default_instance_;
class Database;
class DatabaseDefaultTypeInternal;
extern DatabaseDefaultTypeInternal _Database_default_instance_;
class Group;
class GroupDefaultTypeInternal;
extern GroupDefaultTypeInternal _Group_default_instance_;
class IndexDef;
class IndexDefDefaultTypeInternal;
extern IndexDefDefaultTypeInternal _IndexDef_default_instance_;
class TableDef;
class TableDefDefaultTypeInternal;
extern TableDefDefaultTypeInternal _TableDef_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace type
}  // namespace hybridse
namespace google {
namespace protobuf {
template<> ::hybridse::type::CataLog* Arena::CreateMaybeMessage<::hybridse::type::CataLog>(Arena*);
template<> ::hybridse::type::ColumnDef* Arena::CreateMaybeMessage<::hybridse::type::ColumnDef>(Arena*);
template<> ::hybridse::type::Database* Arena::CreateMaybeMessage<::hybridse::type::Database>(Arena*);
template<> ::hybridse::type::Group* Arena::CreateMaybeMessage<::hybridse::type::Group>(Arena*);
template<> ::hybridse::type::IndexDef* Arena::CreateMaybeMessage<::hybridse::type::IndexDef>(Arena*);
template<> ::hybridse::type::TableDef* Arena::CreateMaybeMessage<::hybridse::type::TableDef>(Arena*);
template<> ::hybridse::type::User* Arena::CreateMaybeMessage<::hybridse::type::User>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace hybridse {
namespace type {

enum Type {
  kBool = 0,
  kInt16 = 1,
  kInt32 = 3,
  kInt64 = 5,
  kFloat = 7,
  kDouble = 8,
  kVarchar = 9,
  kDate = 10,
  kTimestamp = 11,
  kBlob = 12,
  kNull = 101
};
bool Type_IsValid(int value);
const Type Type_MIN = kBool;
const Type Type_MAX = kNull;
const int Type_ARRAYSIZE = Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_descriptor();
inline const ::std::string& Type_Name(Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_descriptor(), value);
}
inline bool Type_Parse(
    const ::std::string& name, Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
enum TTLType {
  kTTLTimeLive = 1,
  kTTLCountLive = 2,
  kTTLTimeLiveAndCountLive = 3,
  kTTLTimeLiveOrCountLive = 4,
  kTTLNone = 5
};
bool TTLType_IsValid(int value);
const TTLType TTLType_MIN = kTTLTimeLive;
const TTLType TTLType_MAX = kTTLNone;
const int TTLType_ARRAYSIZE = TTLType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TTLType_descriptor();
inline const ::std::string& TTLType_Name(TTLType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TTLType_descriptor(), value);
}
inline bool TTLType_Parse(
    const ::std::string& name, TTLType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TTLType>(
    TTLType_descriptor(), name, value);
}
// ===================================================================

class ColumnDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.type.ColumnDef) */ {
 public:
  ColumnDef();
  virtual ~ColumnDef();

  ColumnDef(const ColumnDef& from);

  inline ColumnDef& operator=(const ColumnDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ColumnDef(ColumnDef&& from) noexcept
    : ColumnDef() {
    *this = ::std::move(from);
  }

  inline ColumnDef& operator=(ColumnDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ColumnDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ColumnDef* internal_default_instance() {
    return reinterpret_cast<const ColumnDef*>(
               &_ColumnDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ColumnDef* other);
  friend void swap(ColumnDef& a, ColumnDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ColumnDef* New() const final {
    return CreateMaybeMessage<ColumnDef>(NULL);
  }

  ColumnDef* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ColumnDef>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ColumnDef& from);
  void MergeFrom(const ColumnDef& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ColumnDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .hybridse.type.Type type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::hybridse::type::Type type() const;
  void set_type(::hybridse::type::Type value);

  // optional uint32 offset = 3;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // optional bool is_not_null = 4;
  bool has_is_not_null() const;
  void clear_is_not_null();
  static const int kIsNotNullFieldNumber = 4;
  bool is_not_null() const;
  void set_is_not_null(bool value);

  // optional bool is_constant = 5 [default = false];
  bool has_is_constant() const;
  void clear_is_constant();
  static const int kIsConstantFieldNumber = 5;
  bool is_constant() const;
  void set_is_constant(bool value);

  // @@protoc_insertion_point(class_scope:hybridse.type.ColumnDef)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_offset();
  void clear_has_offset();
  void set_has_is_not_null();
  void clear_has_is_not_null();
  void set_has_is_constant();
  void clear_has_is_constant();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  ::google::protobuf::uint32 offset_;
  bool is_not_null_;
  bool is_constant_;
  friend struct ::protobuf_fe_5ftype_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IndexDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.type.IndexDef) */ {
 public:
  IndexDef();
  virtual ~IndexDef();

  IndexDef(const IndexDef& from);

  inline IndexDef& operator=(const IndexDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IndexDef(IndexDef&& from) noexcept
    : IndexDef() {
    *this = ::std::move(from);
  }

  inline IndexDef& operator=(IndexDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IndexDef* internal_default_instance() {
    return reinterpret_cast<const IndexDef*>(
               &_IndexDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(IndexDef* other);
  friend void swap(IndexDef& a, IndexDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IndexDef* New() const final {
    return CreateMaybeMessage<IndexDef>(NULL);
  }

  IndexDef* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IndexDef>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IndexDef& from);
  void MergeFrom(const IndexDef& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IndexDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string first_keys = 2;
  int first_keys_size() const;
  void clear_first_keys();
  static const int kFirstKeysFieldNumber = 2;
  const ::std::string& first_keys(int index) const;
  ::std::string* mutable_first_keys(int index);
  void set_first_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_first_keys(int index, ::std::string&& value);
  #endif
  void set_first_keys(int index, const char* value);
  void set_first_keys(int index, const char* value, size_t size);
  ::std::string* add_first_keys();
  void add_first_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_first_keys(::std::string&& value);
  #endif
  void add_first_keys(const char* value);
  void add_first_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& first_keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_first_keys();

  // repeated string partion_keys = 4;
  int partion_keys_size() const;
  void clear_partion_keys();
  static const int kPartionKeysFieldNumber = 4;
  const ::std::string& partion_keys(int index) const;
  ::std::string* mutable_partion_keys(int index);
  void set_partion_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_partion_keys(int index, ::std::string&& value);
  #endif
  void set_partion_keys(int index, const char* value);
  void set_partion_keys(int index, const char* value, size_t size);
  ::std::string* add_partion_keys();
  void add_partion_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_partion_keys(::std::string&& value);
  #endif
  void add_partion_keys(const char* value);
  void add_partion_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& partion_keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_partion_keys();

  // repeated uint64 ttl = 5;
  int ttl_size() const;
  void clear_ttl();
  static const int kTtlFieldNumber = 5;
  ::google::protobuf::uint64 ttl(int index) const;
  void set_ttl(int index, ::google::protobuf::uint64 value);
  void add_ttl(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      ttl() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_ttl();

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string second_key = 3;
  bool has_second_key() const;
  void clear_second_key();
  static const int kSecondKeyFieldNumber = 3;
  const ::std::string& second_key() const;
  void set_second_key(const ::std::string& value);
  #if LANG_CXX11
  void set_second_key(::std::string&& value);
  #endif
  void set_second_key(const char* value);
  void set_second_key(const char* value, size_t size);
  ::std::string* mutable_second_key();
  ::std::string* release_second_key();
  void set_allocated_second_key(::std::string* second_key);

  // optional uint32 ts_offset = 7;
  bool has_ts_offset() const;
  void clear_ts_offset();
  static const int kTsOffsetFieldNumber = 7;
  ::google::protobuf::uint32 ts_offset() const;
  void set_ts_offset(::google::protobuf::uint32 value);

  // optional .hybridse.type.TTLType ttl_type = 6;
  bool has_ttl_type() const;
  void clear_ttl_type();
  static const int kTtlTypeFieldNumber = 6;
  ::hybridse::type::TTLType ttl_type() const;
  void set_ttl_type(::hybridse::type::TTLType value);

  // @@protoc_insertion_point(class_scope:hybridse.type.IndexDef)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_second_key();
  void clear_has_second_key();
  void set_has_ttl_type();
  void clear_has_ttl_type();
  void set_has_ts_offset();
  void clear_has_ts_offset();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> first_keys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> partion_keys_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > ttl_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr second_key_;
  ::google::protobuf::uint32 ts_offset_;
  int ttl_type_;
  friend struct ::protobuf_fe_5ftype_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class User : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.type.User) */ {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(User&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const User& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(User* other);
  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline User* New() const final {
    return CreateMaybeMessage<User>(NULL);
  }

  User* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<User>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string token = 2;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // optional uint64 id = 3;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::uint64 id() const;
  void set_id(::google::protobuf::uint64 value);

  // optional uint64 ctime = 4;
  bool has_ctime() const;
  void clear_ctime();
  static const int kCtimeFieldNumber = 4;
  ::google::protobuf::uint64 ctime() const;
  void set_ctime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hybridse.type.User)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_token();
  void clear_has_token();
  void set_has_id();
  void clear_has_id();
  void set_has_ctime();
  void clear_has_ctime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 ctime_;
  friend struct ::protobuf_fe_5ftype_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Group : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.type.Group) */ {
 public:
  Group();
  virtual ~Group();

  Group(const Group& from);

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Group(Group&& from) noexcept
    : Group() {
    *this = ::std::move(from);
  }

  inline Group& operator=(Group&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Group& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Group* internal_default_instance() {
    return reinterpret_cast<const Group*>(
               &_Group_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Group* other);
  friend void swap(Group& a, Group& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Group* New() const final {
    return CreateMaybeMessage<Group>(NULL);
  }

  Group* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Group>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Group* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint64 ctime = 3;
  bool has_ctime() const;
  void clear_ctime();
  static const int kCtimeFieldNumber = 3;
  ::google::protobuf::uint64 ctime() const;
  void set_ctime(::google::protobuf::uint64 value);

  // optional uint64 owner = 4;
  bool has_owner() const;
  void clear_owner();
  static const int kOwnerFieldNumber = 4;
  ::google::protobuf::uint64 owner() const;
  void set_owner(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hybridse.type.Group)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_ctime();
  void clear_has_ctime();
  void set_has_owner();
  void clear_has_owner();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 ctime_;
  ::google::protobuf::uint64 owner_;
  friend struct ::protobuf_fe_5ftype_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CataLog : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.type.CataLog) */ {
 public:
  CataLog();
  virtual ~CataLog();

  CataLog(const CataLog& from);

  inline CataLog& operator=(const CataLog& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CataLog(CataLog&& from) noexcept
    : CataLog() {
    *this = ::std::move(from);
  }

  inline CataLog& operator=(CataLog&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CataLog& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CataLog* internal_default_instance() {
    return reinterpret_cast<const CataLog*>(
               &_CataLog_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CataLog* other);
  friend void swap(CataLog& a, CataLog& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CataLog* New() const final {
    return CreateMaybeMessage<CataLog>(NULL);
  }

  CataLog* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CataLog>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CataLog& from);
  void MergeFrom(const CataLog& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CataLog* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint64 ctime = 3;
  bool has_ctime() const;
  void clear_ctime();
  static const int kCtimeFieldNumber = 3;
  ::google::protobuf::uint64 ctime() const;
  void set_ctime(::google::protobuf::uint64 value);

  // optional uint64 utime = 5;
  bool has_utime() const;
  void clear_utime();
  static const int kUtimeFieldNumber = 5;
  ::google::protobuf::uint64 utime() const;
  void set_utime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hybridse.type.CataLog)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_ctime();
  void clear_has_ctime();
  void set_has_utime();
  void clear_has_utime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 ctime_;
  ::google::protobuf::uint64 utime_;
  friend struct ::protobuf_fe_5ftype_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TableDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.type.TableDef) */ {
 public:
  TableDef();
  virtual ~TableDef();

  TableDef(const TableDef& from);

  inline TableDef& operator=(const TableDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TableDef(TableDef&& from) noexcept
    : TableDef() {
    *this = ::std::move(from);
  }

  inline TableDef& operator=(TableDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TableDef* internal_default_instance() {
    return reinterpret_cast<const TableDef*>(
               &_TableDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(TableDef* other);
  friend void swap(TableDef& a, TableDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TableDef* New() const final {
    return CreateMaybeMessage<TableDef>(NULL);
  }

  TableDef* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TableDef>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TableDef& from);
  void MergeFrom(const TableDef& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TableDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hybridse.type.ColumnDef columns = 1;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 1;
  ::hybridse::type::ColumnDef* mutable_columns(int index);
  ::google::protobuf::RepeatedPtrField< ::hybridse::type::ColumnDef >*
      mutable_columns();
  const ::hybridse::type::ColumnDef& columns(int index) const;
  ::hybridse::type::ColumnDef* add_columns();
  const ::google::protobuf::RepeatedPtrField< ::hybridse::type::ColumnDef >&
      columns() const;

  // repeated .hybridse.type.IndexDef indexes = 7;
  int indexes_size() const;
  void clear_indexes();
  static const int kIndexesFieldNumber = 7;
  ::hybridse::type::IndexDef* mutable_indexes(int index);
  ::google::protobuf::RepeatedPtrField< ::hybridse::type::IndexDef >*
      mutable_indexes();
  const ::hybridse::type::IndexDef& indexes(int index) const;
  ::hybridse::type::IndexDef* add_indexes();
  const ::google::protobuf::RepeatedPtrField< ::hybridse::type::IndexDef >&
      indexes() const;

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string catalog = 4;
  bool has_catalog() const;
  void clear_catalog();
  static const int kCatalogFieldNumber = 4;
  const ::std::string& catalog() const;
  void set_catalog(const ::std::string& value);
  #if LANG_CXX11
  void set_catalog(::std::string&& value);
  #endif
  void set_catalog(const char* value);
  void set_catalog(const char* value, size_t size);
  ::std::string* mutable_catalog();
  ::std::string* release_catalog();
  void set_allocated_catalog(::std::string* catalog);

  // optional uint64 ctime = 5;
  bool has_ctime() const;
  void clear_ctime();
  static const int kCtimeFieldNumber = 5;
  ::google::protobuf::uint64 ctime() const;
  void set_ctime(::google::protobuf::uint64 value);

  // optional uint64 utime = 6;
  bool has_utime() const;
  void clear_utime();
  static const int kUtimeFieldNumber = 6;
  ::google::protobuf::uint64 utime() const;
  void set_utime(::google::protobuf::uint64 value);

  // optional uint32 partitions = 8 [default = 1];
  bool has_partitions() const;
  void clear_partitions();
  static const int kPartitionsFieldNumber = 8;
  ::google::protobuf::uint32 partitions() const;
  void set_partitions(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:hybridse.type.TableDef)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_catalog();
  void clear_has_catalog();
  void set_has_ctime();
  void clear_has_ctime();
  void set_has_utime();
  void clear_has_utime();
  void set_has_partitions();
  void clear_has_partitions();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hybridse::type::ColumnDef > columns_;
  ::google::protobuf::RepeatedPtrField< ::hybridse::type::IndexDef > indexes_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr catalog_;
  ::google::protobuf::uint64 ctime_;
  ::google::protobuf::uint64 utime_;
  ::google::protobuf::uint32 partitions_;
  friend struct ::protobuf_fe_5ftype_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Database : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:hybridse.type.Database) */ {
 public:
  Database();
  virtual ~Database();

  Database(const Database& from);

  inline Database& operator=(const Database& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Database(Database&& from) noexcept
    : Database() {
    *this = ::std::move(from);
  }

  inline Database& operator=(Database&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Database& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Database* internal_default_instance() {
    return reinterpret_cast<const Database*>(
               &_Database_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Database* other);
  friend void swap(Database& a, Database& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Database* New() const final {
    return CreateMaybeMessage<Database>(NULL);
  }

  Database* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Database>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Database& from);
  void MergeFrom(const Database& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Database* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .hybridse.type.TableDef tables = 4;
  int tables_size() const;
  void clear_tables();
  static const int kTablesFieldNumber = 4;
  ::hybridse::type::TableDef* mutable_tables(int index);
  ::google::protobuf::RepeatedPtrField< ::hybridse::type::TableDef >*
      mutable_tables();
  const ::hybridse::type::TableDef& tables(int index) const;
  ::hybridse::type::TableDef* add_tables();
  const ::google::protobuf::RepeatedPtrField< ::hybridse::type::TableDef >&
      tables() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint64 ctime = 2;
  bool has_ctime() const;
  void clear_ctime();
  static const int kCtimeFieldNumber = 2;
  ::google::protobuf::uint64 ctime() const;
  void set_ctime(::google::protobuf::uint64 value);

  // optional uint64 utime = 3;
  bool has_utime() const;
  void clear_utime();
  static const int kUtimeFieldNumber = 3;
  ::google::protobuf::uint64 utime() const;
  void set_utime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:hybridse.type.Database)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_ctime();
  void clear_has_ctime();
  void set_has_utime();
  void clear_has_utime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::hybridse::type::TableDef > tables_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint64 ctime_;
  ::google::protobuf::uint64 utime_;
  friend struct ::protobuf_fe_5ftype_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ColumnDef

// optional string name = 1;
inline bool ColumnDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ColumnDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ColumnDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ColumnDef::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ColumnDef::name() const {
  // @@protoc_insertion_point(field_get:hybridse.type.ColumnDef.name)
  return name_.GetNoArena();
}
inline void ColumnDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.type.ColumnDef.name)
}
#if LANG_CXX11
inline void ColumnDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.type.ColumnDef.name)
}
#endif
inline void ColumnDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.type.ColumnDef.name)
}
inline void ColumnDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.type.ColumnDef.name)
}
inline ::std::string* ColumnDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:hybridse.type.ColumnDef.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ColumnDef::release_name() {
  // @@protoc_insertion_point(field_release:hybridse.type.ColumnDef.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ColumnDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.type.ColumnDef.name)
}

// optional .hybridse.type.Type type = 2;
inline bool ColumnDef::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ColumnDef::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ColumnDef::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ColumnDef::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::hybridse::type::Type ColumnDef::type() const {
  // @@protoc_insertion_point(field_get:hybridse.type.ColumnDef.type)
  return static_cast< ::hybridse::type::Type >(type_);
}
inline void ColumnDef::set_type(::hybridse::type::Type value) {
  assert(::hybridse::type::Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.ColumnDef.type)
}

// optional uint32 offset = 3;
inline bool ColumnDef::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ColumnDef::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ColumnDef::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ColumnDef::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 ColumnDef::offset() const {
  // @@protoc_insertion_point(field_get:hybridse.type.ColumnDef.offset)
  return offset_;
}
inline void ColumnDef::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.ColumnDef.offset)
}

// optional bool is_not_null = 4;
inline bool ColumnDef::has_is_not_null() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ColumnDef::set_has_is_not_null() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ColumnDef::clear_has_is_not_null() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ColumnDef::clear_is_not_null() {
  is_not_null_ = false;
  clear_has_is_not_null();
}
inline bool ColumnDef::is_not_null() const {
  // @@protoc_insertion_point(field_get:hybridse.type.ColumnDef.is_not_null)
  return is_not_null_;
}
inline void ColumnDef::set_is_not_null(bool value) {
  set_has_is_not_null();
  is_not_null_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.ColumnDef.is_not_null)
}

// optional bool is_constant = 5 [default = false];
inline bool ColumnDef::has_is_constant() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ColumnDef::set_has_is_constant() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ColumnDef::clear_has_is_constant() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ColumnDef::clear_is_constant() {
  is_constant_ = false;
  clear_has_is_constant();
}
inline bool ColumnDef::is_constant() const {
  // @@protoc_insertion_point(field_get:hybridse.type.ColumnDef.is_constant)
  return is_constant_;
}
inline void ColumnDef::set_is_constant(bool value) {
  set_has_is_constant();
  is_constant_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.ColumnDef.is_constant)
}

// -------------------------------------------------------------------

// IndexDef

// optional string name = 1;
inline bool IndexDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IndexDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IndexDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IndexDef::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& IndexDef::name() const {
  // @@protoc_insertion_point(field_get:hybridse.type.IndexDef.name)
  return name_.GetNoArena();
}
inline void IndexDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.type.IndexDef.name)
}
#if LANG_CXX11
inline void IndexDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.type.IndexDef.name)
}
#endif
inline void IndexDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.type.IndexDef.name)
}
inline void IndexDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.type.IndexDef.name)
}
inline ::std::string* IndexDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:hybridse.type.IndexDef.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IndexDef::release_name() {
  // @@protoc_insertion_point(field_release:hybridse.type.IndexDef.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IndexDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.type.IndexDef.name)
}

// repeated string first_keys = 2;
inline int IndexDef::first_keys_size() const {
  return first_keys_.size();
}
inline void IndexDef::clear_first_keys() {
  first_keys_.Clear();
}
inline const ::std::string& IndexDef::first_keys(int index) const {
  // @@protoc_insertion_point(field_get:hybridse.type.IndexDef.first_keys)
  return first_keys_.Get(index);
}
inline ::std::string* IndexDef::mutable_first_keys(int index) {
  // @@protoc_insertion_point(field_mutable:hybridse.type.IndexDef.first_keys)
  return first_keys_.Mutable(index);
}
inline void IndexDef::set_first_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hybridse.type.IndexDef.first_keys)
  first_keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void IndexDef::set_first_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hybridse.type.IndexDef.first_keys)
  first_keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void IndexDef::set_first_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  first_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hybridse.type.IndexDef.first_keys)
}
inline void IndexDef::set_first_keys(int index, const char* value, size_t size) {
  first_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hybridse.type.IndexDef.first_keys)
}
inline ::std::string* IndexDef::add_first_keys() {
  // @@protoc_insertion_point(field_add_mutable:hybridse.type.IndexDef.first_keys)
  return first_keys_.Add();
}
inline void IndexDef::add_first_keys(const ::std::string& value) {
  first_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hybridse.type.IndexDef.first_keys)
}
#if LANG_CXX11
inline void IndexDef::add_first_keys(::std::string&& value) {
  first_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hybridse.type.IndexDef.first_keys)
}
#endif
inline void IndexDef::add_first_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  first_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hybridse.type.IndexDef.first_keys)
}
inline void IndexDef::add_first_keys(const char* value, size_t size) {
  first_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hybridse.type.IndexDef.first_keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IndexDef::first_keys() const {
  // @@protoc_insertion_point(field_list:hybridse.type.IndexDef.first_keys)
  return first_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IndexDef::mutable_first_keys() {
  // @@protoc_insertion_point(field_mutable_list:hybridse.type.IndexDef.first_keys)
  return &first_keys_;
}

// optional string second_key = 3;
inline bool IndexDef::has_second_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IndexDef::set_has_second_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IndexDef::clear_has_second_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IndexDef::clear_second_key() {
  second_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_second_key();
}
inline const ::std::string& IndexDef::second_key() const {
  // @@protoc_insertion_point(field_get:hybridse.type.IndexDef.second_key)
  return second_key_.GetNoArena();
}
inline void IndexDef::set_second_key(const ::std::string& value) {
  set_has_second_key();
  second_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.type.IndexDef.second_key)
}
#if LANG_CXX11
inline void IndexDef::set_second_key(::std::string&& value) {
  set_has_second_key();
  second_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.type.IndexDef.second_key)
}
#endif
inline void IndexDef::set_second_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_second_key();
  second_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.type.IndexDef.second_key)
}
inline void IndexDef::set_second_key(const char* value, size_t size) {
  set_has_second_key();
  second_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.type.IndexDef.second_key)
}
inline ::std::string* IndexDef::mutable_second_key() {
  set_has_second_key();
  // @@protoc_insertion_point(field_mutable:hybridse.type.IndexDef.second_key)
  return second_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IndexDef::release_second_key() {
  // @@protoc_insertion_point(field_release:hybridse.type.IndexDef.second_key)
  if (!has_second_key()) {
    return NULL;
  }
  clear_has_second_key();
  return second_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IndexDef::set_allocated_second_key(::std::string* second_key) {
  if (second_key != NULL) {
    set_has_second_key();
  } else {
    clear_has_second_key();
  }
  second_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), second_key);
  // @@protoc_insertion_point(field_set_allocated:hybridse.type.IndexDef.second_key)
}

// repeated string partion_keys = 4;
inline int IndexDef::partion_keys_size() const {
  return partion_keys_.size();
}
inline void IndexDef::clear_partion_keys() {
  partion_keys_.Clear();
}
inline const ::std::string& IndexDef::partion_keys(int index) const {
  // @@protoc_insertion_point(field_get:hybridse.type.IndexDef.partion_keys)
  return partion_keys_.Get(index);
}
inline ::std::string* IndexDef::mutable_partion_keys(int index) {
  // @@protoc_insertion_point(field_mutable:hybridse.type.IndexDef.partion_keys)
  return partion_keys_.Mutable(index);
}
inline void IndexDef::set_partion_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:hybridse.type.IndexDef.partion_keys)
  partion_keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void IndexDef::set_partion_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:hybridse.type.IndexDef.partion_keys)
  partion_keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void IndexDef::set_partion_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  partion_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:hybridse.type.IndexDef.partion_keys)
}
inline void IndexDef::set_partion_keys(int index, const char* value, size_t size) {
  partion_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:hybridse.type.IndexDef.partion_keys)
}
inline ::std::string* IndexDef::add_partion_keys() {
  // @@protoc_insertion_point(field_add_mutable:hybridse.type.IndexDef.partion_keys)
  return partion_keys_.Add();
}
inline void IndexDef::add_partion_keys(const ::std::string& value) {
  partion_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:hybridse.type.IndexDef.partion_keys)
}
#if LANG_CXX11
inline void IndexDef::add_partion_keys(::std::string&& value) {
  partion_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:hybridse.type.IndexDef.partion_keys)
}
#endif
inline void IndexDef::add_partion_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  partion_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:hybridse.type.IndexDef.partion_keys)
}
inline void IndexDef::add_partion_keys(const char* value, size_t size) {
  partion_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:hybridse.type.IndexDef.partion_keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
IndexDef::partion_keys() const {
  // @@protoc_insertion_point(field_list:hybridse.type.IndexDef.partion_keys)
  return partion_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
IndexDef::mutable_partion_keys() {
  // @@protoc_insertion_point(field_mutable_list:hybridse.type.IndexDef.partion_keys)
  return &partion_keys_;
}

// repeated uint64 ttl = 5;
inline int IndexDef::ttl_size() const {
  return ttl_.size();
}
inline void IndexDef::clear_ttl() {
  ttl_.Clear();
}
inline ::google::protobuf::uint64 IndexDef::ttl(int index) const {
  // @@protoc_insertion_point(field_get:hybridse.type.IndexDef.ttl)
  return ttl_.Get(index);
}
inline void IndexDef::set_ttl(int index, ::google::protobuf::uint64 value) {
  ttl_.Set(index, value);
  // @@protoc_insertion_point(field_set:hybridse.type.IndexDef.ttl)
}
inline void IndexDef::add_ttl(::google::protobuf::uint64 value) {
  ttl_.Add(value);
  // @@protoc_insertion_point(field_add:hybridse.type.IndexDef.ttl)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
IndexDef::ttl() const {
  // @@protoc_insertion_point(field_list:hybridse.type.IndexDef.ttl)
  return ttl_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
IndexDef::mutable_ttl() {
  // @@protoc_insertion_point(field_mutable_list:hybridse.type.IndexDef.ttl)
  return &ttl_;
}

// optional .hybridse.type.TTLType ttl_type = 6;
inline bool IndexDef::has_ttl_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IndexDef::set_has_ttl_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IndexDef::clear_has_ttl_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IndexDef::clear_ttl_type() {
  ttl_type_ = 1;
  clear_has_ttl_type();
}
inline ::hybridse::type::TTLType IndexDef::ttl_type() const {
  // @@protoc_insertion_point(field_get:hybridse.type.IndexDef.ttl_type)
  return static_cast< ::hybridse::type::TTLType >(ttl_type_);
}
inline void IndexDef::set_ttl_type(::hybridse::type::TTLType value) {
  assert(::hybridse::type::TTLType_IsValid(value));
  set_has_ttl_type();
  ttl_type_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.IndexDef.ttl_type)
}

// optional uint32 ts_offset = 7;
inline bool IndexDef::has_ts_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IndexDef::set_has_ts_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IndexDef::clear_has_ts_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IndexDef::clear_ts_offset() {
  ts_offset_ = 0u;
  clear_has_ts_offset();
}
inline ::google::protobuf::uint32 IndexDef::ts_offset() const {
  // @@protoc_insertion_point(field_get:hybridse.type.IndexDef.ts_offset)
  return ts_offset_;
}
inline void IndexDef::set_ts_offset(::google::protobuf::uint32 value) {
  set_has_ts_offset();
  ts_offset_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.IndexDef.ts_offset)
}

// -------------------------------------------------------------------

// User

// optional string name = 1;
inline bool User::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void User::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void User::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void User::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& User::name() const {
  // @@protoc_insertion_point(field_get:hybridse.type.User.name)
  return name_.GetNoArena();
}
inline void User::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.type.User.name)
}
#if LANG_CXX11
inline void User::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.type.User.name)
}
#endif
inline void User::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.type.User.name)
}
inline void User::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.type.User.name)
}
inline ::std::string* User::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:hybridse.type.User.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_name() {
  // @@protoc_insertion_point(field_release:hybridse.type.User.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.type.User.name)
}

// optional string token = 2;
inline bool User::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void User::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void User::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void User::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& User::token() const {
  // @@protoc_insertion_point(field_get:hybridse.type.User.token)
  return token_.GetNoArena();
}
inline void User::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.type.User.token)
}
#if LANG_CXX11
inline void User::set_token(::std::string&& value) {
  set_has_token();
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.type.User.token)
}
#endif
inline void User::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.type.User.token)
}
inline void User::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.type.User.token)
}
inline ::std::string* User::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:hybridse.type.User.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_token() {
  // @@protoc_insertion_point(field_release:hybridse.type.User.token)
  if (!has_token()) {
    return NULL;
  }
  clear_has_token();
  return token_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:hybridse.type.User.token)
}

// optional uint64 id = 3;
inline bool User::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void User::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void User::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void User::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 User::id() const {
  // @@protoc_insertion_point(field_get:hybridse.type.User.id)
  return id_;
}
inline void User::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.User.id)
}

// optional uint64 ctime = 4;
inline bool User::has_ctime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void User::set_has_ctime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void User::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void User::clear_ctime() {
  ctime_ = GOOGLE_ULONGLONG(0);
  clear_has_ctime();
}
inline ::google::protobuf::uint64 User::ctime() const {
  // @@protoc_insertion_point(field_get:hybridse.type.User.ctime)
  return ctime_;
}
inline void User::set_ctime(::google::protobuf::uint64 value) {
  set_has_ctime();
  ctime_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.User.ctime)
}

// -------------------------------------------------------------------

// Group

// optional string name = 1;
inline bool Group::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Group::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Group::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Group::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Group::name() const {
  // @@protoc_insertion_point(field_get:hybridse.type.Group.name)
  return name_.GetNoArena();
}
inline void Group::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.type.Group.name)
}
#if LANG_CXX11
inline void Group::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.type.Group.name)
}
#endif
inline void Group::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.type.Group.name)
}
inline void Group::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.type.Group.name)
}
inline ::std::string* Group::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:hybridse.type.Group.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Group::release_name() {
  // @@protoc_insertion_point(field_release:hybridse.type.Group.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Group::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.type.Group.name)
}

// optional uint64 ctime = 3;
inline bool Group::has_ctime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Group::set_has_ctime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Group::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Group::clear_ctime() {
  ctime_ = GOOGLE_ULONGLONG(0);
  clear_has_ctime();
}
inline ::google::protobuf::uint64 Group::ctime() const {
  // @@protoc_insertion_point(field_get:hybridse.type.Group.ctime)
  return ctime_;
}
inline void Group::set_ctime(::google::protobuf::uint64 value) {
  set_has_ctime();
  ctime_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.Group.ctime)
}

// optional uint64 owner = 4;
inline bool Group::has_owner() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Group::set_has_owner() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Group::clear_has_owner() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Group::clear_owner() {
  owner_ = GOOGLE_ULONGLONG(0);
  clear_has_owner();
}
inline ::google::protobuf::uint64 Group::owner() const {
  // @@protoc_insertion_point(field_get:hybridse.type.Group.owner)
  return owner_;
}
inline void Group::set_owner(::google::protobuf::uint64 value) {
  set_has_owner();
  owner_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.Group.owner)
}

// -------------------------------------------------------------------

// CataLog

// optional string name = 1;
inline bool CataLog::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CataLog::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CataLog::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CataLog::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& CataLog::name() const {
  // @@protoc_insertion_point(field_get:hybridse.type.CataLog.name)
  return name_.GetNoArena();
}
inline void CataLog::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.type.CataLog.name)
}
#if LANG_CXX11
inline void CataLog::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.type.CataLog.name)
}
#endif
inline void CataLog::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.type.CataLog.name)
}
inline void CataLog::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.type.CataLog.name)
}
inline ::std::string* CataLog::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:hybridse.type.CataLog.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CataLog::release_name() {
  // @@protoc_insertion_point(field_release:hybridse.type.CataLog.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CataLog::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.type.CataLog.name)
}

// optional uint64 ctime = 3;
inline bool CataLog::has_ctime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CataLog::set_has_ctime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CataLog::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CataLog::clear_ctime() {
  ctime_ = GOOGLE_ULONGLONG(0);
  clear_has_ctime();
}
inline ::google::protobuf::uint64 CataLog::ctime() const {
  // @@protoc_insertion_point(field_get:hybridse.type.CataLog.ctime)
  return ctime_;
}
inline void CataLog::set_ctime(::google::protobuf::uint64 value) {
  set_has_ctime();
  ctime_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.CataLog.ctime)
}

// optional uint64 utime = 5;
inline bool CataLog::has_utime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CataLog::set_has_utime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CataLog::clear_has_utime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CataLog::clear_utime() {
  utime_ = GOOGLE_ULONGLONG(0);
  clear_has_utime();
}
inline ::google::protobuf::uint64 CataLog::utime() const {
  // @@protoc_insertion_point(field_get:hybridse.type.CataLog.utime)
  return utime_;
}
inline void CataLog::set_utime(::google::protobuf::uint64 value) {
  set_has_utime();
  utime_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.CataLog.utime)
}

// -------------------------------------------------------------------

// TableDef

// repeated .hybridse.type.ColumnDef columns = 1;
inline int TableDef::columns_size() const {
  return columns_.size();
}
inline void TableDef::clear_columns() {
  columns_.Clear();
}
inline ::hybridse::type::ColumnDef* TableDef::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:hybridse.type.TableDef.columns)
  return columns_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hybridse::type::ColumnDef >*
TableDef::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:hybridse.type.TableDef.columns)
  return &columns_;
}
inline const ::hybridse::type::ColumnDef& TableDef::columns(int index) const {
  // @@protoc_insertion_point(field_get:hybridse.type.TableDef.columns)
  return columns_.Get(index);
}
inline ::hybridse::type::ColumnDef* TableDef::add_columns() {
  // @@protoc_insertion_point(field_add:hybridse.type.TableDef.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hybridse::type::ColumnDef >&
TableDef::columns() const {
  // @@protoc_insertion_point(field_list:hybridse.type.TableDef.columns)
  return columns_;
}

// optional string name = 2;
inline bool TableDef::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableDef::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableDef::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableDef::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TableDef::name() const {
  // @@protoc_insertion_point(field_get:hybridse.type.TableDef.name)
  return name_.GetNoArena();
}
inline void TableDef::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.type.TableDef.name)
}
#if LANG_CXX11
inline void TableDef::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.type.TableDef.name)
}
#endif
inline void TableDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.type.TableDef.name)
}
inline void TableDef::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.type.TableDef.name)
}
inline ::std::string* TableDef::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:hybridse.type.TableDef.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableDef::release_name() {
  // @@protoc_insertion_point(field_release:hybridse.type.TableDef.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.type.TableDef.name)
}

// optional string catalog = 4;
inline bool TableDef::has_catalog() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableDef::set_has_catalog() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableDef::clear_has_catalog() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableDef::clear_catalog() {
  catalog_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_catalog();
}
inline const ::std::string& TableDef::catalog() const {
  // @@protoc_insertion_point(field_get:hybridse.type.TableDef.catalog)
  return catalog_.GetNoArena();
}
inline void TableDef::set_catalog(const ::std::string& value) {
  set_has_catalog();
  catalog_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.type.TableDef.catalog)
}
#if LANG_CXX11
inline void TableDef::set_catalog(::std::string&& value) {
  set_has_catalog();
  catalog_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.type.TableDef.catalog)
}
#endif
inline void TableDef::set_catalog(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_catalog();
  catalog_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.type.TableDef.catalog)
}
inline void TableDef::set_catalog(const char* value, size_t size) {
  set_has_catalog();
  catalog_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.type.TableDef.catalog)
}
inline ::std::string* TableDef::mutable_catalog() {
  set_has_catalog();
  // @@protoc_insertion_point(field_mutable:hybridse.type.TableDef.catalog)
  return catalog_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TableDef::release_catalog() {
  // @@protoc_insertion_point(field_release:hybridse.type.TableDef.catalog)
  if (!has_catalog()) {
    return NULL;
  }
  clear_has_catalog();
  return catalog_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TableDef::set_allocated_catalog(::std::string* catalog) {
  if (catalog != NULL) {
    set_has_catalog();
  } else {
    clear_has_catalog();
  }
  catalog_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), catalog);
  // @@protoc_insertion_point(field_set_allocated:hybridse.type.TableDef.catalog)
}

// optional uint64 ctime = 5;
inline bool TableDef::has_ctime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableDef::set_has_ctime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableDef::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableDef::clear_ctime() {
  ctime_ = GOOGLE_ULONGLONG(0);
  clear_has_ctime();
}
inline ::google::protobuf::uint64 TableDef::ctime() const {
  // @@protoc_insertion_point(field_get:hybridse.type.TableDef.ctime)
  return ctime_;
}
inline void TableDef::set_ctime(::google::protobuf::uint64 value) {
  set_has_ctime();
  ctime_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.TableDef.ctime)
}

// optional uint64 utime = 6;
inline bool TableDef::has_utime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableDef::set_has_utime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableDef::clear_has_utime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableDef::clear_utime() {
  utime_ = GOOGLE_ULONGLONG(0);
  clear_has_utime();
}
inline ::google::protobuf::uint64 TableDef::utime() const {
  // @@protoc_insertion_point(field_get:hybridse.type.TableDef.utime)
  return utime_;
}
inline void TableDef::set_utime(::google::protobuf::uint64 value) {
  set_has_utime();
  utime_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.TableDef.utime)
}

// repeated .hybridse.type.IndexDef indexes = 7;
inline int TableDef::indexes_size() const {
  return indexes_.size();
}
inline void TableDef::clear_indexes() {
  indexes_.Clear();
}
inline ::hybridse::type::IndexDef* TableDef::mutable_indexes(int index) {
  // @@protoc_insertion_point(field_mutable:hybridse.type.TableDef.indexes)
  return indexes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hybridse::type::IndexDef >*
TableDef::mutable_indexes() {
  // @@protoc_insertion_point(field_mutable_list:hybridse.type.TableDef.indexes)
  return &indexes_;
}
inline const ::hybridse::type::IndexDef& TableDef::indexes(int index) const {
  // @@protoc_insertion_point(field_get:hybridse.type.TableDef.indexes)
  return indexes_.Get(index);
}
inline ::hybridse::type::IndexDef* TableDef::add_indexes() {
  // @@protoc_insertion_point(field_add:hybridse.type.TableDef.indexes)
  return indexes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hybridse::type::IndexDef >&
TableDef::indexes() const {
  // @@protoc_insertion_point(field_list:hybridse.type.TableDef.indexes)
  return indexes_;
}

// optional uint32 partitions = 8 [default = 1];
inline bool TableDef::has_partitions() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TableDef::set_has_partitions() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TableDef::clear_has_partitions() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TableDef::clear_partitions() {
  partitions_ = 1u;
  clear_has_partitions();
}
inline ::google::protobuf::uint32 TableDef::partitions() const {
  // @@protoc_insertion_point(field_get:hybridse.type.TableDef.partitions)
  return partitions_;
}
inline void TableDef::set_partitions(::google::protobuf::uint32 value) {
  set_has_partitions();
  partitions_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.TableDef.partitions)
}

// -------------------------------------------------------------------

// Database

// optional string name = 1;
inline bool Database::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Database::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Database::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Database::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Database::name() const {
  // @@protoc_insertion_point(field_get:hybridse.type.Database.name)
  return name_.GetNoArena();
}
inline void Database::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:hybridse.type.Database.name)
}
#if LANG_CXX11
inline void Database::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:hybridse.type.Database.name)
}
#endif
inline void Database::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:hybridse.type.Database.name)
}
inline void Database::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:hybridse.type.Database.name)
}
inline ::std::string* Database::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:hybridse.type.Database.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Database::release_name() {
  // @@protoc_insertion_point(field_release:hybridse.type.Database.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Database::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:hybridse.type.Database.name)
}

// optional uint64 ctime = 2;
inline bool Database::has_ctime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Database::set_has_ctime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Database::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Database::clear_ctime() {
  ctime_ = GOOGLE_ULONGLONG(0);
  clear_has_ctime();
}
inline ::google::protobuf::uint64 Database::ctime() const {
  // @@protoc_insertion_point(field_get:hybridse.type.Database.ctime)
  return ctime_;
}
inline void Database::set_ctime(::google::protobuf::uint64 value) {
  set_has_ctime();
  ctime_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.Database.ctime)
}

// optional uint64 utime = 3;
inline bool Database::has_utime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Database::set_has_utime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Database::clear_has_utime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Database::clear_utime() {
  utime_ = GOOGLE_ULONGLONG(0);
  clear_has_utime();
}
inline ::google::protobuf::uint64 Database::utime() const {
  // @@protoc_insertion_point(field_get:hybridse.type.Database.utime)
  return utime_;
}
inline void Database::set_utime(::google::protobuf::uint64 value) {
  set_has_utime();
  utime_ = value;
  // @@protoc_insertion_point(field_set:hybridse.type.Database.utime)
}

// repeated .hybridse.type.TableDef tables = 4;
inline int Database::tables_size() const {
  return tables_.size();
}
inline void Database::clear_tables() {
  tables_.Clear();
}
inline ::hybridse::type::TableDef* Database::mutable_tables(int index) {
  // @@protoc_insertion_point(field_mutable:hybridse.type.Database.tables)
  return tables_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::hybridse::type::TableDef >*
Database::mutable_tables() {
  // @@protoc_insertion_point(field_mutable_list:hybridse.type.Database.tables)
  return &tables_;
}
inline const ::hybridse::type::TableDef& Database::tables(int index) const {
  // @@protoc_insertion_point(field_get:hybridse.type.Database.tables)
  return tables_.Get(index);
}
inline ::hybridse::type::TableDef* Database::add_tables() {
  // @@protoc_insertion_point(field_add:hybridse.type.Database.tables)
  return tables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::hybridse::type::TableDef >&
Database::tables() const {
  // @@protoc_insertion_point(field_list:hybridse.type.Database.tables)
  return tables_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace type
}  // namespace hybridse

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::hybridse::type::Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hybridse::type::Type>() {
  return ::hybridse::type::Type_descriptor();
}
template <> struct is_proto_enum< ::hybridse::type::TTLType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::hybridse::type::TTLType>() {
  return ::hybridse::type::TTLType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_fe_5ftype_2eproto
