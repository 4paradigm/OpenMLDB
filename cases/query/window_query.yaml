# Copyright 2021 4Paradigm
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

cases:
  - id: 0
    desc: Window SQL ROWS_RANGE Between
    db: db1
    sql: |
      SELECT col1 as id, col2, col5, sum(col1) OVER w1 as w1_col1_sum, sum(col3) OVER w1 as w1_col3_sum,
      sum(col4) OVER w1 as w1_col4_sum, sum(col2) OVER w1 as w1_col2_sum,
      sum(col5) OVER w1 as w1_col5_sum,
      col6 as col6 FROM t1
      WINDOW w1 AS (PARTITION BY t1.col2 ORDER BY t1.col5 ROWS_RANGE BETWEEN 3 PRECEDING AND CURRENT ROW) limit 10;
    inputs:
      - name: t1
        resource: cases/resource/simple_t1.yaml
        index: index2:col2:col5
    expect:
      schema: id:int32, col2:int16, col5:int64, w1_col1_sum:int32, w1_col3_sum:float, w1_col4_sum:double, w1_col2_sum:int16, w1_col5_sum:int64, col6:string
      order: id
      data: |
        1, 5, 1, 1, 1.1, 11.1, 5, 1, 1
        2, 5, 2, 3, 3.3, 33.3, 10, 3, 22
        3, 55, 1, 3, 3.3, 33.3, 55, 1, 333
        4, 55, 2, 7, 7.7, 77.7, 110, 3, 4444
        5, 55, 3, 12, 13.2, 133.2, 165, 6, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  - id: 1
    desc: window ROWS Between
    sql: |
      SELECT id, pk1, col1, std_ts,
      sum(col1) OVER w1 as w1_col1_sum
      FROM t1
      WINDOW w1 AS (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 1 PRECEDING AND CURRENT ROW);
    standard_sql: true
    inputs:
      - name: t1
        schema: id:int, pk1:string, col1:int32, std_ts:timestamp
        index: index2:pk1:std_ts
        data: |
          1, A, 1, 1590115420000
          2, B, 1, 1590115420000
          3, A, 2, 1590115430000
          4, B, 2, 1590115430000
          5, A, 3, 1590115440000
          6, B, 3, 1590115440000
          7, A, 4, 1590115450000
          8, B, 4, 1590115450000
          9, A, 5, 1590115460000

    expect:
      schema: id:int, pk1:string, col1:int, std_ts:timestamp, w1_col1_sum:int
      order: id
      data: |
        1, A, 1, 1590115420000, 1
        2, B, 1, 1590115420000, 1
        3, A, 2, 1590115430000, 3
        4, B, 2, 1590115430000, 3
        5, A, 3, 1590115440000, 5
        6, B, 3, 1590115440000, 5
        7, A, 4, 1590115450000, 7
        8, B, 4, 1590115450000, 7
        9, A, 5, 1590115460000, 9

  - id: 2
    desc: Window SQL PK是字符串
    db: db1
    sql: |
      SELECT col1 as id, col0, col5, sum(col1) OVER w1 as w1_col1_sum, sum(col3) OVER w1 as w1_col3_sum,
      sum(col4) OVER w1 as w1_col4_sum, sum(col2) OVER w1 as w1_col2_sum,
      sum(col5) OVER w1 as w1_col5_sum,
      col6 as col6 FROM t1
      WINDOW w1 AS (PARTITION BY t1.col0 ORDER BY t1.col5 ROWS_RANGE BETWEEN 3 PRECEDING AND CURRENT ROW) limit 10;
    inputs:
      - name: t1
        resource: cases/resource/simple_t1.yaml
        index: index2:col0:col5
    expect:
      schema: id:int32, col0:string, col5:int64, w1_col1_sum:int32, w1_col3_sum:float, w1_col4_sum:double, w1_col2_sum:int16, w1_col5_sum:int64, col6:string
      order: id
      data: |
        1, 0, 1, 1, 1.1, 11.1, 5, 1, 1
        2, 0, 2, 3, 3.3, 33.3, 10, 3, 22
        3, 1, 1, 3, 3.3, 33.3, 55, 1, 333
        4, 1, 2, 7, 7.7, 77.7, 110, 3, 4444
        5, 2, 3, 5, 5.5, 55.5, 55, 3, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  - id: 3
    desc: 单行+两window+自定义聚合函数,w1命中索引,w2未命中索引
    mode: rtidb-unsupport
    sql: |
      SELECT col1 as id, col2, col0, col5, sum(col1) OVER w1 as w1_col1_sum, sum(col3) OVER w1 as w1_col3_sum,
      sum(col4) OVER w2 as w2_col4_sum, sum(col2) OVER w2 as w2_col2_sum, sum(col5) OVER w2 as w2_col5_sum,
      col6 as col6 FROM t1 WINDOW
      w1 AS (PARTITION BY col2 ORDER BY col5 ROWS_RANGE BETWEEN 3 PRECEDING AND CURRENT ROW),
      w2 AS (PARTITION BY col0 ORDER BY col5 ROWS_RANGE BETWEEN 3 PRECEDING AND CURRENT ROW) limit 10;
    inputs:
      - name: t1
        resource: cases/resource/simple_t1.yaml
        index: index2:col2:col5
    expect:
      schema: id:int32, col2:int16, col0:string, col5:int64, w1_col1_sum:int32, w1_col3_sum:float, w2_col4_sum:double, w2_col2_sum:int16, w2_col5_sum:int64, col6:string
      order: id
      data: |
        1, 5, 0, 1, 1, 1.1, 11.1, 5, 1, 1
        2, 5, 0, 2, 3, 3.3, 33.3, 10, 3, 22
        3, 55, 1, 1, 3, 3.3, 33.3, 55, 1, 333
        4, 55, 1, 2, 7, 7.7, 77.7, 110, 3, 4444
        5, 55, 2, 3, 12, 13.2, 55.5, 55, 3, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  - id: 4
    desc: 单行+两window+自定义聚合函数，w1和w2命中索引
    sql: |
      SELECT col2, col0, col5, sum(col1) OVER w1 as w1_col1_sum, sum(col3) OVER w1 as w1_col3_sum,
      sum(col4) OVER w2 as w2_col4_sum, sum(col2) OVER w2 as w2_col2_sum, sum(col5) OVER w2 as w2_col5_sum,
      col1, col6 as col6 FROM t1 WINDOW
      w1 AS (PARTITION BY col2 ORDER BY col5 ROWS_RANGE BETWEEN 3 PRECEDING AND CURRENT ROW),
      w2 AS (PARTITION BY col0 ORDER BY col5 ROWS_RANGE BETWEEN 3 PRECEDING AND CURRENT ROW) limit 10;
    inputs:
      - name: t1
        resource: cases/resource/simple_t1.yaml
        index: index2:col2:col5,index0:col0:col5
    expect:
      schema: col2:int16, col0:string, col5:int64, w1_col1_sum:int32, w1_col3_sum:float, w2_col4_sum:double, w2_col2_sum:int16, w2_col5_sum:int64, col1:int32, col6:string
      order: col1
      data: |
        5, 0, 1, 1, 1.1, 11.1, 5, 1, 1, 1
        5, 0, 2, 3, 3.3, 33.3, 10, 3, 2, 22
        55, 1, 1, 3, 3.3, 33.3, 55, 1, 3, 333
        55, 1, 2, 7, 7.7, 77.7, 110, 3, 4, 4444
        55, 2, 3, 12, 13.2, 55.5, 55, 3, 5, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  - id: 5
    desc: 单行+三个window+自定义聚合函数,w1和w2命中索引
    mode: rtidb-unsupport
    sql: |
      SELECT col2, col0, col5, sum(col1) OVER w1 as w1_col1_sum, sum(col3) OVER w1 as w1_col3_sum,
      sum(col4) OVER w3 as w3_col4_sum, sum(col2) OVER w2 as w2_col2_sum, sum(col5) OVER w2 as w2_col5_sum,
      col1, col6 as col6 FROM t1 WINDOW
      w1 AS (PARTITION BY col2 ORDER BY col5 ROWS_RANGE BETWEEN 3 PRECEDING AND CURRENT ROW),
      w2 AS (PARTITION BY col0 ORDER BY col5 ROWS_RANGE BETWEEN 3 PRECEDING AND CURRENT ROW),
      w3 AS (PARTITION BY col1 ORDER BY col5 ROWS_RANGE BETWEEN 3 PRECEDING AND CURRENT ROW) limit 10;
    inputs:
      - name: t1
        resource: cases/resource/simple_t1.yaml
        index: index2:col2:col5,index0:col0:col5
    expect:
      schema: col2:int16, col0:string, col5:int64, w1_col1_sum:int32, w1_col3_sum:float, w3_col4_sum:double, w2_col2_sum:int16, w2_col5_sum:int64, col1:int32, col6:string
      order: col1
      data: |
        5, 0, 1, 1, 1.1, 11.1, 5, 1, 1, 1
        5, 0, 2, 3, 3.3, 22.2, 10, 3, 2, 22
        55, 1, 1, 3, 3.3, 33.3, 55, 1, 3, 333
        55, 1, 2, 7, 7.7, 44.4, 110, 3, 4, 4444
        55, 2, 3, 12, 13.2, 55.5, 55, 3, 5, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  - id: 6
    desc: Window SQL 双PK 均命中索引
    db: db1
    sql: |
      SELECT col0, col2, col5, sum(col1) OVER w1 as w1_col1_sum, sum(col3) OVER w1 as w1_col3_sum,
      sum(col4) OVER w1 as w1_col4_sum, sum(col2) OVER w1 as w1_col2_sum,
      sum(col5) OVER w1 as w1_col5_sum, col1,
      col6 as col6 FROM t1
      WINDOW w1 AS (PARTITION BY t1.col0, t1.col2 ORDER BY t1.col5 ROWS_RANGE BETWEEN 3 PRECEDING AND CURRENT ROW) limit 10;
    inputs:
      - name: t1
        schema: col0:string, col1:int32, col2:int16, col3:float, col4:double, col5:int64, col6:string
        index: index2:col0|col2:col5
        data: |
          0, 1, 5, 1.1, 11.1, 1, 1
          0, 2, 5, 2.2, 22.2, 2, 22
          1, 3, 55, 3.3, 33.3, 1, 333
          1, 4, 55, 4.4, 44.4, 2, 4444
          2, 5, 55, 5.5, 55.5, 1, aaaaa
          2, 6, 55, 6.6, 66.6, 2, bbbbbb
          2, 7, 555, 7.7, 77.7, 3, ccccccc
          2, 8, 555, 8.8, 88.8, 4, dddddddd
          2, 9, 555, 9.9, 99.9, 5, eeeeeeeee
    expect:
      schema: col0:string, col2:int16, col5:int64, w1_col1_sum:int32, w1_col3_sum:float, w1_col4_sum:double, w1_col2_sum:int16, w1_col5_sum:int64, col1:int32, col6:string
      order: col1
      data: |
        0, 5, 1, 1, 1.1, 11.1, 5, 1, 1, 1
        0, 5, 2, 3, 3.3, 33.3, 10, 3, 2, 22
        1, 55, 1, 3, 3.3, 33.3, 55, 1, 3, 333
        1, 55, 2, 7, 7.7, 77.7, 110, 3, 4, 4444
        2, 55, 1, 5, 5.5, 55.5, 55, 1, 5, aaaaa
        2, 55, 2, 11, 12.1, 122.1, 110, 3, 6, bbbbbb
        2, 555, 3, 7, 7.7, 77.7, 555, 3, 7, ccccccc
        2, 555, 4, 15, 16.5, 166.5, 1110, 7,  8, dddddddd
        2, 555, 5, 24, 26.4, 266.4, 1665, 12, 9, eeeeeeeee
  - id: 7
    desc: Window SQL 双PK col2未命中索引
    mode: rtidb-unsupport
    db: db1
    sql: |
      SELECT col0, col2, col5, sum(col1) OVER w1 as w1_col1_sum, sum(col3) OVER w1 as w1_col3_sum,
      sum(col4) OVER w1 as w1_col4_sum, sum(col2) OVER w1 as w1_col2_sum,
      sum(col5) OVER w1 as w1_col5_sum, col1,
      col6 as col6 FROM t1
      WINDOW w1 AS (PARTITION BY t1.col0, t1.col2 ORDER BY t1.col5 ROWS_RANGE BETWEEN 3 PRECEDING AND CURRENT ROW) limit 10;
    inputs:
      - name: t1
        schema: col0:string, col1:int32, col2:int16, col3:float, col4:double, col5:int64, col6:string
        index: index2:col0:col5
        data: |
          0, 1, 5, 1.1, 11.1, 1, 1
          0, 2, 5, 2.2, 22.2, 2, 22
          1, 3, 55, 3.3, 33.3, 1, 333
          1, 4, 55, 4.4, 44.4, 2, 4444
          2, 5, 55, 5.5, 55.5, 1, aaaaa
          2, 6, 55, 6.6, 66.6, 2, bbbbbb
          2, 7, 555, 7.7, 77.7, 3, ccccccc
          2, 8, 555, 8.8, 88.8, 4, dddddddd
          2, 9, 555, 9.9, 99.9, 5, eeeeeeeee
    expect:
      schema: col0:string, col2:int16, col5:int64, w1_col1_sum:int32, w1_col3_sum:float, w1_col4_sum:double, w1_col2_sum:int16, w1_col5_sum:int64, col1:int32, col6:string
      order: col1
      data: |
        0, 5, 1, 1, 1.1, 11.1, 5, 1, 1, 1
        0, 5, 2, 3, 3.3, 33.3, 10, 3, 2, 22
        1, 55, 1, 3, 3.3, 33.3, 55, 1, 3, 333
        1, 55, 2, 7, 7.7, 77.7, 110, 3, 4, 4444
        2, 55, 1, 5, 5.5, 55.5, 55, 1, 5, aaaaa
        2, 55, 2, 11, 12.1, 122.1, 110, 3, 6, bbbbbb
        2, 555, 3, 7, 7.7, 77.7, 555, 3, 7, ccccccc
        2, 555, 4, 15, 16.5, 166.5, 1110, 7,  8, dddddddd
        2, 555, 5, 24, 26.4, 266.4, 1665, 12, 9, eeeeeeeee
  - id: 8
    desc: Window SQL Order By Timestamp
    db: db1
    sql: |
      SELECT col1 as id, col2, std_ts, sum(col3) OVER w1 as w1_col3_sum FROM t1
      WINDOW w1 AS (PARTITION BY t1.col2 ORDER BY t1.std_ts ROWS_RANGE BETWEEN 3s PRECEDING AND CURRENT ROW) limit 10;
    inputs:
      - name: t1
        resource: cases/resource/simple_t1_ts.yaml
        index: index2:col2:std_ts
    expect:
      schema: id:int32, col2:int16, std_ts:timestamp, w1_col3_sum:float
      order: id
      data: |
        1, 5, 1590115420000, 1.1
        2, 5, 1590115421000, 3.3
        3, 55, 1590115422000, 3.3
        4, 55, 1590115423000, 7.7
        5, 55, 1590115424000, 13.2
  - id: 9
    desc: Window SQL Order By Timestamp, timestamp列聚合
    db: db1
    sql: |
      SELECT col1 as id, col2, std_ts, sum(std_ts) OVER w1 as w1_ts_sum,
      min(std_ts) OVER w1 as w1_ts_min,
      max(std_ts) OVER w1 as w1_ts_max
      FROM t1
      WINDOW w1 AS (PARTITION BY t1.col2 ORDER BY t1.std_ts ROWS_RANGE BETWEEN 3s PRECEDING AND CURRENT ROW) limit 10;
    inputs:
      - name: t1
        resource: cases/resource/simple_t1_ts.yaml
        index: index2:col2:std_ts
    expect:
      schema: id:int32, col2:int16, std_ts:timestamp, w1_ts_sum:timestamp, w1_ts_min:timestamp, w1_ts_max:timestamp
      order: id
      data: |
        1, 5, 1590115420000, 1590115420000, 1590115420000, 1590115420000
        2, 5, 1590115421000, 3180230841000, 1590115420000, 1590115421000
        3, 55, 1590115422000, 1590115422000, 1590115422000, 1590115422000
        4, 55, 1590115423000, 3180230845000, 1590115422000, 1590115423000
        5, 55, 1590115424000, 4770346269000, 1590115422000, 1590115424000

  - id: 10
    desc: Window SQL Order By Timestamp, Date列聚合
    db: db1
    sql: |
      SELECT col1 as id, col2, std_ts,
      min(std_date) OVER w1 as w1_date_min,
      max(std_date) OVER w1 as w1_date_max
      FROM t1
      WINDOW w1 AS (PARTITION BY t1.col2 ORDER BY t1.std_ts ROWS_RANGE BETWEEN 3s PRECEDING AND CURRENT ROW) limit 10;
    inputs:
      - name: t1
        schema: col0:string, col1:int32, col2:int16, col3:float, col4:double, col5:int64, col6:string, std_ts:timestamp, std_date:date
        index: index2:col2:std_ts
        data: |
          0, 1, 5, 1.1, 11.1, 1, 1, 1590115420000, 2020-05-27
          0, 2, 5, 2.2, 22.2, 2, 22, 1590115421000, 2020-05-28
          1, 3, 55, 3.3, 33.3, 1, 333, 1590115422000, 2020-05-20
          1, 4, 55, 4.4, 44.4, 2, 4444, 1590115423000, 2020-05-21
          2, 5, 55, 5.5, 55.5, 3, aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa, 1590115424000 , 2020-05-22

    expect:
      schema: id:int32, col2:int16, std_ts:timestamp, w1_date_min:date, w1_date_max:date
      order: id
      data: |
        1, 5, 1590115420000, 2020-05-27, 2020-05-27
        2, 5, 1590115421000, 2020-05-27, 2020-05-28
        3, 55, 1590115422000, 2020-05-20,  2020-05-20
        4, 55, 1590115423000,  2020-05-20,  2020-05-21
        5, 55, 1590115424000,  2020-05-20,  2020-05-22
  - id: 11
    desc: 匿名Window ROWS_RANGE
    db: db1
    sql: |
      SELECT col1 as id, col2, std_ts, sum(col3) OVER
      (PARTITION BY t1.col2 ORDER BY t1.std_ts ROWS_RANGE BETWEEN 3s PRECEDING AND CURRENT ROW) as w1_col3_sum FROM t1 limit 10;
    inputs:
      - name: t1
        resource: cases/resource/simple_t1_ts.yaml
        index: index2:col2:std_ts
    expect:
      schema: id:int32, col2:int16, std_ts:timestamp, w1_col3_sum:float
      order: id
      data: |
        1, 5, 1590115420000, 1.1
        2, 5, 1590115421000, 3.3
        3, 55, 1590115422000, 3.3
        4, 55, 1590115423000, 7.7
        5, 55, 1590115424000, 13.2

  - id: 12
    desc: window ROWS_RANGE merge
    sql: |
      SELECT id, pk1, col1, std_ts,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS_RANGE BETWEEN 10s PRECEDING AND CURRENT ROW) as w1_col1_sum,
      sum(col1) OVER w2 as w2_col1_sum,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS_RANGE BETWEEN 30s PRECEDING AND CURRENT ROW) as w3_col1_sum
      FROM t1
      WINDOW w2 AS (PARTITION BY pk1 ORDER BY std_ts ROWS_RANGE BETWEEN 20s PRECEDING AND CURRENT ROW);
    inputs:
      - name: t1
        schema: id:int, pk1:string, col1:int32, std_ts:timestamp
        index: index2:pk1:std_ts
        data: |
          1, A, 1, 1590115420000
          2, B, 1, 1590115420000
          3, A, 2, 1590115430000
          4, B, 2, 1590115430000
          5, A, 3, 1590115440000
          6, B, 3, 1590115440000
          7, A, 4, 1590115450000
          8, B, 4, 1590115450000
          9, A, 5, 1590115460000
          10, B, 5, 1590115460000
          11, A, 6, 1590115470000
          12, A, 7, 1590115480000
          13, A, 8, 1590115490000
          14, A, 9, 1590115500000

    expect:
      schema: id:int, pk1:string, col1:int, std_ts:timestamp, w1_col1_sum:int, w2_col1_sum:int, w3_col1_sum:int
      order: id
      data: |
        1, A, 1, 1590115420000, 1, 1, 1
        2, B, 1, 1590115420000, 1, 1, 1
        3, A, 2, 1590115430000, 3, 3, 3
        4, B, 2, 1590115430000, 3, 3, 3
        5, A, 3, 1590115440000, 5, 6, 6
        6, B, 3, 1590115440000, 5, 6, 6
        7, A, 4, 1590115450000, 7, 9, 10
        8, B, 4, 1590115450000, 7, 9, 10
        9, A, 5, 1590115460000, 9, 12, 14
        10, B, 5, 1590115460000, 9, 12, 14
        11, A, 6, 1590115470000, 11, 15, 18
        12, A, 7, 1590115480000, 13, 18, 22
        13, A, 8, 1590115490000, 15, 21, 26
        14, A, 9, 1590115500000, 17, 24, 30
  - id: 13
    desc: window ROWS merge
    sql: |
      SELECT id, pk1, col1, std_ts,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) as w1_col1_sum,
      sum(col1) OVER w2 as w2_col1_sum,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) as w3_col1_sum
      FROM t1
      WINDOW w2 AS (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 2 PRECEDING AND CURRENT ROW);
    standard_sql: true
    inputs:
      - name: t1
        schema: id:int, pk1:string, col1:int32, std_ts:timestamp
        index: index2:pk1:std_ts
        data: |
          1, A, 1, 1590115420000
          2, B, 1, 1590115420000
          3, A, 2, 1590115430000
          4, B, 2, 1590115430000
          5, A, 3, 1590115440000
          6, B, 3, 1590115440000
          7, A, 4, 1590115450000
          8, B, 4, 1590115450000
          9, A, 5, 1590115460000
          10, B, 5, 1590115460000
          11, A, 6, 1590115470000
          12, A, 7, 1590115480000
          13, A, 8, 1590115490000
          14, A, 9, 1590115500000

    expect:
      schema: id:int, pk1:string, col1:int, std_ts:timestamp, w1_col1_sum:int, w2_col1_sum:int, w3_col1_sum:int
      order: id
      data: |
        1, A, 1, 1590115420000, 1, 1, 1
        2, B, 1, 1590115420000, 1, 1, 1
        3, A, 2, 1590115430000, 3, 3, 3
        4, B, 2, 1590115430000, 3, 3, 3
        5, A, 3, 1590115440000, 5, 6, 6
        6, B, 3, 1590115440000, 5, 6, 6
        7, A, 4, 1590115450000, 7, 9, 10
        8, B, 4, 1590115450000, 7, 9, 10
        9, A, 5, 1590115460000, 9, 12, 14
        10, B, 5, 1590115460000, 9, 12, 14
        11, A, 6, 1590115470000, 11, 15, 18
        12, A, 7, 1590115480000, 13, 18, 22
        13, A, 8, 1590115490000, 15, 21, 26
        14, A, 9, 1590115500000, 17, 24, 30
  - id: 14
    desc: window ROWS and ROWS_RANGE merge
    sql: |
      SELECT id, pk1, col1, std_ts,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) as w1_col1_sum,
      sum(col1) OVER w2 as w2_col1_sum,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS_RANGE BETWEEN 30s PRECEDING AND CURRENT ROW) as w3_col1_sum
      FROM t1
      WINDOW w2 AS (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 2 PRECEDING AND CURRENT ROW);
    inputs:
      - name: t1
        schema: id:int, pk1:string, col1:int32, std_ts:timestamp
        index: index2:pk1:std_ts
        data: |
          1, A, 1, 1590115420000
          2, B, 1, 1590115420000
          3, A, 2, 1590115430000
          4, B, 2, 1590115430000
          5, A, 3, 1590115440000
          6, B, 3, 1590115440000
          7, A, 4, 1590115450000
          8, B, 4, 1590115450000
          9, A, 5, 1590115460000
          10, B, 5, 1590115460000
          11, A, 6, 1590115470000
          12, A, 7, 1590115480000
          13, A, 8, 1590115490000
          14, A, 9, 1590115500000

    expect:
      schema: id:int, pk1:string, col1:int, std_ts:timestamp, w1_col1_sum:int, w2_col1_sum:int, w3_col1_sum:int
      order: id
      data: |
        1, A, 1, 1590115420000, 1, 1, 1
        2, B, 1, 1590115420000, 1, 1, 1
        3, A, 2, 1590115430000, 3, 3, 3
        4, B, 2, 1590115430000, 3, 3, 3
        5, A, 3, 1590115440000, 5, 6, 6
        6, B, 3, 1590115440000, 5, 6, 6
        7, A, 4, 1590115450000, 7, 9, 10
        8, B, 4, 1590115450000, 7, 9, 10
        9, A, 5, 1590115460000, 9, 12, 14
        10, B, 5, 1590115460000, 9, 12, 14
        11, A, 6, 1590115470000, 11, 15, 18
        12, A, 7, 1590115480000, 13, 18, 22
        13, A, 8, 1590115490000, 15, 21, 26
        14, A, 9, 1590115500000, 17, 24, 30
  - id: 15
    desc: window ROWS_RANGE 包含纯历史小窗口(不包含CURRENT ROW)
    sql: |
      SELECT id, pk1, col1, std_ts,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS_RANGE BETWEEN 10s PRECEDING AND CURRENT ROW) as w1_col1_sum,
      sum(col1) OVER w2 as w2_col1_sum,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS_RANGE BETWEEN 40s PRECEDING AND 21s PRECEDING) as w3_col1_sum
      FROM t1
      WINDOW w2 AS (PARTITION BY pk1 ORDER BY std_ts ROWS_RANGE BETWEEN 20s PRECEDING AND CURRENT ROW);
    inputs:
      - name: t1
        schema: id:int, pk1:string, col1:int32, std_ts:timestamp
        index: index2:pk1:std_ts
        data: |
          1, A, 1, 1590115420000
          2, B, 1, 1590115420000
          3, A, 2, 1590115430000
          4, B, 2, 1590115430000
          5, A, 3, 1590115440000
          6, B, 3, 1590115440000
          7, A, 4, 1590115450000
          8, B, 4, 1590115450000
          9, A, 5, 1590115460000
          10, B, 5, 1590115460000
          11, A, 6, 1590115470000
          12, A, 7, 1590115480000
          13, A, 8, 1590115490000
          14, A, 9, 1590115500000

    expect:
      schema: id:int, pk1:string, col1:int, std_ts:timestamp, w1_col1_sum:int, w2_col1_sum:int, w3_col1_sum:int
      order: id
      data: |
        1, A, 1, 1590115420000, 1, 1, NULL
        2, B, 1, 1590115420000, 1, 1, NULL
        3, A, 2, 1590115430000, 3, 3, NULL
        4, B, 2, 1590115430000, 3, 3, NULL
        5, A, 3, 1590115440000, 5, 6, NULL
        6, B, 3, 1590115440000, 5, 6, NULL
        7, A, 4, 1590115450000, 7, 9, 1
        8, B, 4, 1590115450000, 7, 9, 1
        9, A, 5, 1590115460000, 9, 12, 3
        10, B, 5, 1590115460000, 9, 12, 3
        11, A, 6, 1590115470000, 11, 15, 5
        12, A, 7, 1590115480000, 13, 18, 7
        13, A, 8, 1590115490000, 15, 21, 9
        14, A, 9, 1590115500000, 17, 24, 11

  - id: 16
    desc: window ROWS merge, 包含纯历史小窗口
    sql: |
      SELECT id, pk1, col1, std_ts,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) as w1_col1_sum,
      sum(col1) OVER w2 as w2_col1_sum,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 3 PRECEDING AND 2 PRECEDING) as w3_col1_sum
      FROM t1
      WINDOW w2 AS (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 2 PRECEDING AND CURRENT ROW);
    standard_sql: true
    standard_sql_compatible: false
    inputs:
      - name: t1
        schema: id:int, pk1:string, col1:int32, std_ts:timestamp
        index: index2:pk1:std_ts
        data: |
          1, A, 1, 1590115420000
          2, B, 1, 1590115420000
          3, A, 2, 1590115430000
          4, B, 2, 1590115430000
          5, A, 3, 1590115440000
          6, B, 3, 1590115440000
          7, A, 4, 1590115450000
          8, B, 4, 1590115450000
          9, A, 5, 1590115460000
          10, B, 5, 1590115460000
          11, A, 6, 1590115470000
          12, A, 7, 1590115480000
          13, A, 8, 1590115490000
          14, A, 9, 1590115500000

    expect:
      schema: id:int, pk1:string, col1:int, std_ts:timestamp, w1_col1_sum:int, w2_col1_sum:int, w3_col1_sum:int
      order: id
      data: |
        1, A, 1, 1590115420000, 1, 1, NULL
        2, B, 1, 1590115420000, 1, 1, NULL
        3, A, 2, 1590115430000, 3, 3, NULL
        4, B, 2, 1590115430000, 3, 3, NULL
        5, A, 3, 1590115440000, 5, 6, 1
        6, B, 3, 1590115440000, 5, 6, 1
        7, A, 4, 1590115450000, 7, 9, 3
        8, B, 4, 1590115450000, 7, 9, 3
        9, A, 5, 1590115460000, 9, 12, 5
        10, B, 5, 1590115460000, 9, 12, 5
        11, A, 6, 1590115470000, 11, 15, 7
        12, A, 7, 1590115480000, 13, 18, 9
        13, A, 8, 1590115490000, 15, 21, 11
        14, A, 9, 1590115500000, 17, 24, 13
  - id: 17
    desc: window ROWS and ROWS_RANGE merge, 包含纯历史小窗口
    sql: |
      SELECT id, pk1, col1, std_ts,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) as w1_col1_sum,
      sum(col1) OVER w2 as w2_col1_sum,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS_RANGE BETWEEN 30s PRECEDING AND CURRENT ROW) as w3_col1_sum,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 3 PRECEDING AND 2 PRECEDING) as w4_col1_sum,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS_RANGE BETWEEN 40s PRECEDING AND 21s PRECEDING) as w5_col1_sum
      FROM t1
      WINDOW w2 AS (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 2 PRECEDING AND CURRENT ROW);
    inputs:
      - name: t1
        schema: id:int, pk1:string, col1:int32, std_ts:timestamp
        index: index2:pk1:std_ts
        data: |
          1, A, 1, 1590115420000
          2, B, 1, 1590115420000
          3, A, 2, 1590115430000
          4, B, 2, 1590115430000
          5, A, 3, 1590115440000
          6, B, 3, 1590115440000
          7, A, 4, 1590115450000
          8, B, 4, 1590115450000
          9, A, 5, 1590115460000
          10, B, 5, 1590115460000
          11, A, 6, 1590115470000
          12, A, 7, 1590115480000
          13, A, 8, 1590115490000
          14, A, 9, 1590115500000

    expect:
      schema: id:int, pk1:string, col1:int, std_ts:timestamp, w1_col1_sum:int, w2_col1_sum:int, w3_col1_sum:int, w4_col1_sum:int, w5_col1_sum:int
      order: id
      data: |
        1, A, 1, 1590115420000, 1, 1, 1, NULL, NULL
        2, B, 1, 1590115420000, 1, 1, 1, NULL, NULL
        3, A, 2, 1590115430000, 3, 3, 3, NULL, NULL
        4, B, 2, 1590115430000, 3, 3, 3, NULL, NULL
        5, A, 3, 1590115440000, 5, 6, 6, 1, NULL
        6, B, 3, 1590115440000, 5, 6, 6, 1, NULL
        7, A, 4, 1590115450000, 7, 9, 10, 3, 1
        8, B, 4, 1590115450000, 7, 9, 10, 3, 1
        9, A, 5, 1590115460000, 9, 12, 14, 5, 3
        10, B, 5, 1590115460000, 9, 12, 14, 5, 3
        11, A, 6, 1590115470000, 11, 15, 18, 7, 5
        12, A, 7, 1590115480000, 13, 18, 22, 9, 7
        13, A, 8, 1590115490000, 15, 21, 26, 11, 9
        14, A, 9, 1590115500000, 17, 24, 30, 13, 11
  - id: 18
    desc: window ROWS Between N PRECEDING and M PRECEDING
    sql: |
      SELECT id, pk1, col1, std_ts,
      sum(col1) OVER w1 as w1_col1_sum
      FROM t1
      WINDOW w1 AS (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 2 PRECEDING AND 1 PRECEDING);
    inputs:
      - name: t1
        schema: id:int, pk1:string, col1:int32, std_ts:timestamp
        index: index2:pk1:std_ts
        data: |
          1, A, 1, 1590115420000
          2, B, 1, 1590115420000
          3, A, 2, 1590115430000
          4, B, 2, 1590115430000
          5, A, 3, 1590115440000
          6, B, 3, 1590115440000
          7, A, 4, 1590115450000
          8, B, 4, 1590115450000
          9, A, 5, 1590115460000

    expect:
      schema: id:int, pk1:string, col1:int, std_ts:timestamp, w1_col1_sum:int
      order: id
      data: |
        1, A, 1, 1590115420000, NULL
        2, B, 1, 1590115420000, NULL
        3, A, 2, 1590115430000, 1
        4, B, 2, 1590115430000, 1
        5, A, 3, 1590115440000, 3
        6, B, 3, 1590115440000, 3
        7, A, 4, 1590115450000, 5
        8, B, 4, 1590115450000, 5
        9, A, 5, 1590115460000, 7
  - id: 19
    desc: window ROWS_RANGE Between N PRECEDING and M PRECEDING
    sql: |
      SELECT id, pk1, col1, std_ts,
      sum(col1) OVER w1 as w1_col1_sum
      FROM t1
      WINDOW w1 AS (PARTITION BY pk1 ORDER BY std_ts ROWS_RANGE BETWEEN 20s PRECEDING AND 10s PRECEDING);
    inputs:
      - name: t1
        schema: id:int, pk1:string, col1:int32, std_ts:timestamp
        index: index2:pk1:std_ts
        data: |
          1, A, 1, 1590115420000
          2, B, 1, 1590115420000
          3, A, 2, 1590115430000
          4, B, 2, 1590115430000
          5, A, 3, 1590115440000
          6, B, 3, 1590115440000
          7, A, 4, 1590115450000
          8, B, 4, 1590115450000
          9, A, 5, 1590115460000

    expect:
      schema: id:int, pk1:string, col1:int, std_ts:timestamp, w1_col1_sum:int
      order: id
      data: |
        1, A, 1, 1590115420000, NULL
        2, B, 1, 1590115420000, NULL
        3, A, 2, 1590115430000, 1
        4, B, 2, 1590115430000, 1
        5, A, 3, 1590115440000, 3
        6, B, 3, 1590115440000, 3
        7, A, 4, 1590115450000, 5
        8, B, 4, 1590115450000, 5
        9, A, 5, 1590115460000, 7
  - id: 20
    mode: cluster-unsupport
    desc: lastjoin+window ROWS and ROWS_RANGE merge, 包含纯历史小窗口
    sql: |
      SELECT id, pk1, col1, std_ts,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) as w1_col1_sum,
      sum(col1) OVER w2 as w2_col1_sum,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS_RANGE BETWEEN 30s PRECEDING AND CURRENT ROW) as w3_col1_sum,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 3 PRECEDING AND 2 PRECEDING) as w4_col1_sum,
      sum(col1) OVER (PARTITION BY pk1 ORDER BY std_ts ROWS_RANGE BETWEEN 40s PRECEDING AND 21s PRECEDING) as w5_col1_sum
      FROM t1 last join t2 order by t2.std_ts2 on t1.pk1 = t2.pk2
      WINDOW w2 AS (PARTITION BY pk1 ORDER BY std_ts ROWS BETWEEN 2 PRECEDING AND CURRENT ROW);
    inputs:
      - name: t1
        schema: id:int, pk1:string, col1:int32, std_ts:timestamp
        index: index2:pk1:std_ts
        data: |
          1, A, 1, 1590115420000
          2, B, 1, 1590115420000
          3, A, 2, 1590115430000
          4, B, 2, 1590115430000
          5, A, 3, 1590115440000
          6, B, 3, 1590115440000
          7, A, 4, 1590115450000
          8, B, 4, 1590115450000
          9, A, 5, 1590115460000
          10, B, 5, 1590115460000
          11, A, 6, 1590115470000
          12, A, 7, 1590115480000
          13, A, 8, 1590115490000
          14, A, 9, 1590115500000
      - name: t2
        schema: id2:int, pk2:string, col2:int32, std_ts2:timestamp
        index: index2:pk2:std_ts2
        data: |
          1, A, 1, 1590115420000
          2, B, 1, 1590115420000
          3, A, 2, 1590115430000
          4, B, 2, 1590115430000
          5, A, 3, 1590115440000
          6, B, 3, 1590115440000
          7, A, 4, 1590115450000
          8, B, 4, 1590115450000
          9, A, 5, 1590115460000
          10, B, 5, 1590115460000
          11, A, 6, 1590115470000
          12, A, 7, 1590115480000
          13, A, 8, 1590115490000
          14, A, 9, 1590115500000
    expect:
      schema: id:int, pk1:string, col1:int, std_ts:timestamp, w1_col1_sum:int, w2_col1_sum:int, w3_col1_sum:int, w4_col1_sum:int, w5_col1_sum:int
      order: id
      data: |
        1, A, 1, 1590115420000, 1, 1, 1, NULL, NULL
        2, B, 1, 1590115420000, 1, 1, 1, NULL, NULL
        3, A, 2, 1590115430000, 3, 3, 3, NULL, NULL
        4, B, 2, 1590115430000, 3, 3, 3, NULL, NULL
        5, A, 3, 1590115440000, 5, 6, 6, 1, NULL
        6, B, 3, 1590115440000, 5, 6, 6, 1, NULL
        7, A, 4, 1590115450000, 7, 9, 10, 3, 1
        8, B, 4, 1590115450000, 7, 9, 10, 3, 1
        9, A, 5, 1590115460000, 9, 12, 14, 5, 3
        10, B, 5, 1590115460000, 9, 12, 14, 5, 3
        11, A, 6, 1590115470000, 11, 15, 18, 7, 5
        12, A, 7, 1590115480000, 13, 18, 22, 9, 7
        13, A, 8, 1590115490000, 15, 21, 26, 11, 9
        14, A, 9, 1590115500000, 17, 24, 30, 13, 11
  - id: 21
    desc: window query after last join with a table, index hasn't been optimized
    db: db1
    mode: performance-sensitive-unsupport, cluster-unsupport
    sql: |
       SELECT sum(t1.col1) over w1 as sum_t1_col1, str1 as t2_str1
       FROM t1
       last join t2 order by t2.col1
       on t1.col1 = t2.col1 and t1.col2 = t2.col0
       WINDOW w1 AS (
        PARTITION BY t1.col2 ORDER BY t1.col1
        ROWS_RANGE BETWEEN 3 PRECEDING AND CURRENT ROW
       ) limit 10;
    inputs:
      - name: t1
        columns: ["col0 string", "col1 bigint", "col2 int"]
        indexs: ["index1:col0:col1"]
        rows:
          - ["0", 1, 5]
          - ["0", 2, 5]
      - name: t2
        columns: ["str0 string", "str1 string", "col0 int", "col1 bigint"]
        indexs: ["index2:str0:col1"]
        rows:
          - ["2", "EEEEE", 55, 5]
          - ["1", "DDDD", 55, 4]
          - ["1", "CCC", 55, 3]
    expect:
      success: true
  - id: 22
    sql: |
      select
        account_no,
        count(account_no) over w as cnt,
         -- check if there exists in window that right source agreement_no is null
         nvl2(nth_value_where(account_no, 1, isnull(agreement_no)) over w, 1, 0) as feat1,
         case when count_where(account_no, isnull(agreement_no)) over w > 0 then 1 else 0 end as feat2
      from (select account_no, 0 as agreement_no, cast(90000 as timestamp) as ts from request)
      window w as (
         union (select t14.account_no, t16.agreement_nox as agreement_no, t14.ts from t14 last join t16 on t14.agreement_no = t16.agreement_nox)
         partition by account_no order by ts
         rows between unbounded preceding and current row
         exclude current_row instance_not_in_window
      )
    inputs:
      - name: request
        columns: ["account_no int"]
        indexs: ['idx:account_no']
        data: |
          100
          200
          300
          400
      - name: t14
        columns:
          - account_no int
          - agreement_no int
          - ts timestamp
        indexs: ["idx1:account_no:ts"]
        data: |
          100, 201, 1000
          100, 202, 1000
          200, 203, 4000
          400, 204, 4000
      - name: t16
        columns:
          - agreement_nox int
          - ts timestamp
        indexs: ["idx3:agreement_nox:ts"]
        data: |
          202, 1000
          204, 1000
    expect:
      columns:
        - account_no int
        - cnt int64
        - feat1 int
        - feat2 int
      order: account_no
      data: |
        100, 2, 1, 1
        200, 1, 1, 1
        300, 0, 0, 0
        400, 1, 0, 0

  - id: 23
    sql: |
      select
        gp_id,
        count(gp_id) over w as cnt,
        -- t2 matches and t3 not matches
        count_where(gp_id, not is_null(lcond) and is_null(cond)) over w as feat1,
      from (select id as gp_id, 0 as lcond, 0 as cond, cast(90000 as timestamp) as ts from request)
      window w as (
         union (select t1.gp_id, t2.cond as lcond, t3.cond as cond, t1.ts from
             t1 last join t2 on t1.gp_id = t2.account
             last join t3 on t1.cond = t3.cond)
         partition by gp_id order by ts
         rows between unbounded preceding and current row
         exclude current_row instance_not_in_window
      )
    inputs:
      - name: request
        columns: ["id int"]
        indexs: ['idx:id']
        data: |
          100
          200
          300
          400
      - name: t1
        columns:
          - gp_id int
          - cond int
          - ts timestamp
        indexs:
          - idx2:gp_id:ts
        data: |
          100, 201, 10000
          100, 201, 10000
          200, 203, 10000
          400, 204, 10000
          400, 205, 10000
      - name: t2
        columns:
          - account int
          - cond int
          - ts timestamp
        indexs: ["idx1:account:ts"]
        data: |
          100, 201, 1000
          200, 203, 4000
          400, 209, 4000
      - name: t3
        columns:
          - cond int
          - ts timestamp
        indexs: ["idx3:cond:ts"]
        data: |
          201, 1000
          208, 1000
    expect:
      columns:
        - gp_id int
        - cnt int64
        - feat1 int64
      order: gp_id
      data: |
        100, 2, 0
        200, 1, 1
        300, 0, 0
        400, 2, 2

  # ======================================================================
  # WINDOW without ORDER BY
  # 
  # batch mode tests skipped since ordering in WINDOW is undefined, we only
  # verify result for request mode, that's implmentation defined order, not SQL standard
  # ======================================================================
  - id: 24
    desc: ROWS WINDOW WITHOUT ORDER BY
    mode: batch-unsupport
    inputs:
      - name: t1
        columns:
          - id int
          - gp int
          - ts timestamp
        indexs:
          - idx:gp:ts
        data: |
          1, 100, 20000
          2, 100, 10000
          3, 400, 20000
          4, 400, 10000
          5, 400, 15000
          6, 400, 40000
    sql: |
      select id, count(ts) over w as agg
      from t1
      window w as (
        partition by gp
        rows between 2 open preceding and current row
      )
    request_plan: |
      PROJECT(type=Aggregation)
        REQUEST_UNION(partition_keys=(), orders=, rows=(, 2 OPEN PRECEDING, 0 CURRENT), index_keys=(gp))
          DATA_PROVIDER(request=t1)
          DATA_PROVIDER(type=Partition, table=t1, index=idx)
    cluster_request_plan: |
      SIMPLE_PROJECT(sources=(id, agg))
        REQUEST_JOIN(type=kJoinTypeConcat)
          SIMPLE_PROJECT(sources=(id))
            DATA_PROVIDER(request=t1)
          PROJECT(type=Aggregation)
            REQUEST_UNION(partition_keys=(), orders=, rows=(, 2 OPEN PRECEDING, 0 CURRENT), index_keys=(gp))
              DATA_PROVIDER(request=t1)
              DATA_PROVIDER(type=Partition, table=t1, index=idx)
    expect:
      columns: ["id int", "agg int64"]
      order: id
      data: |
        1, 1
        2, 2
        3, 1
        4, 2
        5, 2
        6, 2
  - id: 25
    desc: RANGE WINDOW WITHOUT ORDER BY
    mode: batch-unsupport
    inputs:
      - name: t1
        columns:
          - id int
          - gp int
          - ts timestamp
        indexs:
          - idx:gp:ts
        data: |
          1, 100, 20000
          2, 100, 10000
          3, 400, 20000
          4, 400, 10
          5, 400, 15000
    sql: |
      select id, count(ts) over w as agg
      from t1
      window w as (
        partition by gp
        rows_range between unbounded preceding and current row
      )
    request_plan: |
      PROJECT(type=Aggregation)
        REQUEST_UNION(partition_keys=(), orders=, range=(, 0 PRECEDING UNBOUND, 0 CURRENT), index_keys=(gp))
          DATA_PROVIDER(request=t1)
          DATA_PROVIDER(type=Partition, table=t1, index=idx)
    cluster_request_plan: |
      SIMPLE_PROJECT(sources=(id, agg))
        REQUEST_JOIN(type=kJoinTypeConcat)
          SIMPLE_PROJECT(sources=(id))
            DATA_PROVIDER(request=t1)
          PROJECT(type=Aggregation)
            REQUEST_UNION(partition_keys=(), orders=, range=(, 0 PRECEDING UNBOUND, 0 CURRENT), index_keys=(gp))
              DATA_PROVIDER(request=t1)
              DATA_PROVIDER(type=Partition, table=t1, index=idx)
    expect:
      columns: ["id int", "agg int64"]
      order: id
      data: |
        1, 1
        2, 2
        3, 1
        4, 2
        5, 3
  - id: 26
    desc: RANGE-type WINDOW WITHOUT ORDER BY + WINDOW attributes
    mode: batch-unsupport
    inputs:
      - name: t1
        columns:
          - id int
          - gp int
          - ts timestamp
        indexs:
          - idx:gp:ts
        data: |
          1, 100, 20000
          2, 100, 10000
          3, 400, 20000
          4, 400, 10000
          5, 400, 15000
      - name: t2
        columns:
          - id int
          - gp int
          - ts timestamp
        indexs:
          - idx:gp:ts
        data: |
          1, 100, 20000
          2, 100, 10000
          3, 400, 20000
          4, 400, 10000
          5, 400, 15000
    sql: |
      select id,
        count(ts) over w1 as agg1,
        count(ts) over w2 as agg2,
        count(ts) over w3 as agg3,
        count(ts) over w4 as agg4,
        count(ts) over w5 as agg5,
        count(ts) over w6 as agg6,
        count(ts) over w7 as agg7,
      from t1
      window w1 as (
        PARTITION by gp
        ROWS_RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW),
      w2 as (partition by gp
        ROWS_RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE CURRENT_ROW),
      w3 as (PARTITION BY gp
        ROWS_RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW MAXSIZE 1),
      w4 as (
        UNION (select * from t2)
        PARTITION BY gp
        ROWS_RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW INSTANCE_NOT_IN_WINDOW),
      w5 as (
        UNION (select * from t2)
        PARTITION BY gp
        ROWS_RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW INSTANCE_NOT_IN_WINDOW EXCLUDE CURRENT_ROW),
      w6 as (
        UNION (select * from t2)
        PARTITION BY gp
        ROWS_RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW MAXSIZE 2 INSTANCE_NOT_IN_WINDOW EXCLUDE CURRENT_ROW),
      w7 as (
        UNION (select * from t2)
        PARTITION BY gp
        ROWS_RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW EXCLUDE CURRENT_ROW)
    expect:
      columns: ["id int", "agg1 int64", "agg2 int64", "agg3 int64", "agg4 int64", "agg5 int64", "agg6 int64", "agg7 int64"]
      order: id
      data: |
        1, 1, 0, 1, 3, 2, 2, 2
        2, 2, 1, 1, 3, 2, 2, 3
        3, 1, 0, 1, 4, 3, 2, 3
        4, 2, 1, 1, 4, 3, 2, 4
        5, 3, 2, 1, 4, 3, 2, 5
  - id: 27
    desc: ROWS-type WINDOW WITHOUT ORDER BY + WINDOW attributes
    mode: batch-unsupport
    inputs:
      - name: t1
        columns:
          - id int
          - gp int
          - ts timestamp
        indexs:
          - idx:gp:ts
        data: |
          1, 100, 20000
          2, 100, 10000
          3, 400, 20000
          4, 400, 10000
          5, 400, 15000
      - name: t2
        columns:
          - id int
          - gp int
          - ts timestamp
        indexs:
          - idx:gp:ts
        data: |
          1, 100, 20000
          2, 100, 10000
          3, 400, 20000
          4, 400, 10000
          5, 400, 15000
    sql: |
      select id,
        count(ts) over w1 as agg1,
        count(ts) over w2 as agg2,
        count(ts) over w3 as agg3,
        count(ts) over w4 as agg4,
      from t1
      window w1 as (
        PARTITION by gp
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW),
      w2 as (partition by gp
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW EXCLUDE CURRENT_ROW),
      w3 as (
        UNION (select * from t2)
        PARTITION BY gp
        ROWS BETWEEN 2 PRECEDING AND CURRENT ROW INSTANCE_NOT_IN_WINDOW),
      w4 as (
        UNION (select * from t2)
        PARTITION BY gp
        ROWS BETWEEN 3 PRECEDING AND CURRENT ROW INSTANCE_NOT_IN_WINDOW EXCLUDE CURRENT_ROW)
    expect:
      columns: ["id int", "agg1 int64", "agg2 int64", "agg3 int64", "agg4 int64"]
      order: id
      data: |
        1, 1, 0, 3, 2
        2, 2, 1, 3, 2
        3, 1, 0, 3, 3
        4, 2, 1, 3, 3
        5, 3, 2, 3, 3
  - id: 28
    # simple case verify it compile & run for batch mode
    desc: RANGE WINDOW WITHOUT ORDER BY
    inputs:
      - name: t1
        columns:
          - id int
          - gp int
          - ts timestamp
        indexs:
          - idx:gp:ts
        data: |
          1, 100, 20000
          2, 100, 10000
          3, 400, 20000
          4, 400, 10
          5, 400, 15000
    sql: |
      select id, count(ts) over w as agg
      from t1
      window w as (
        partition by gp
        rows_range between unbounded preceding and current row
      )
    expect:
      success: true
